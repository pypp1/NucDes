import numpy as np
import matplotlib.pyplot as plt
import scipy.linalg as lng 
from scipy import integrate, interpolate

# ============================
# Geometrical data
# ============================
D_barr_ext = 2.5       #m
D_vess_int = 3.0       #m
t_th_ins = 0.05        #m 
k_th_ins = 1.4         #W/mK
L = 7                  #m
W = 0.01               #ASSUMED: To be changed using ASME III NB4000, as this is only valid for IRIS SG Tubes
sigma_allowable = 400  #MPa     -   Assumed randomly, will have to be defined

# ============================
# Primary fluid
# ============================
T_in = 214 + 273.15        #K
T_out_avg = 254 + 273.15   #K
T_out_max = 270 + 273.15   #K
P_int = 75                 #bar
m_flr = 3227               #kg/s
Cp = 4534                  #J/(kg·K)
rho = 852.5                #kg/m³
mu = 1.259e-4              #Pa·s
k = 0.658                  #W/(m·K)

# ============================
# Containment (CPP) water
# ============================
T_cpp = 70 + 273.15             #K
P_cpp = 75                      #bar
Cp_cpp = 4172.5                 #J/(kg·K)
rho_cpp = 981.2                 #kg/m³
mu_cpp = 4.06e-4                #Pa·s
k_cpp = 0.666                   #W/(m·K)
beta_cpp = 5.57e-4              #1/K
DeltaT = 30                     #K

# ============================
# Steel properties
# ============================
E = 177*1e3                    #MPa
nu = 0.3                  
alpha_l = 1.7e-5               #1/K
k_st = 48.1                    #W/(m·K)
mu_st = 24                     #1/m
sigma_y = np.array([240,232.5,222,216,210,204,199.5,195,190.5,186,181.5,177,171,165,157.5,147])         #MPa
sigma_in = np.array([160,155,148,144,140,136,133,130,127,124,121,118,114,110,105,98])                   #MPa
T_thr = np.array([40,65,100,125,150,175,200,225,250,275,300,325,350,375,400,425])                       #°C

# ============================
# Radiation source
# ============================
Phi_0 = 1.5e13                 #photons/(cm²·s)
E_y = 6.0                      #MeV
E_y_J = E_y * 1.60218e-13      #Joules
B = 1.4                        #Build-up factor

# ============================
# Design Curves
# ============================
data_mu2 = np.array([
    [1.005909000449883, -0.0005260079886943991],
    [1.0091410287143576, -0.0005260079886943991],
    [1.012374426772545, 0.00041914967288114724],
    [1.0156065854935636, 0.0005091646882693368],
    [1.0188384833014943, 0.00041914967288114724],
    [1.0220713921476414, 0.0010267510267512048],
    [1.0253032247273, 0.0008917285036689204],
    [1.0285350573069587, 0.0007567059805866361],
    [1.0317680052900688, 0.0013913118390733725],
    [1.0350011685264768, 0.0021744424729499556],
    [1.0382356065096865, 0.003837148400048118],
    [1.0414705802965591, 0.005869558854633583],
    [1.0447030749431787, 0.006191362534646139],
    [1.047933521422057, 0.005099930473064784],
    [1.0511624839577467, 0.0029845776114434397],
    [1.0543950014342616, 0.0033221339191489285],
    [1.057629182231713, 0.00480738167305339],
    [1.0607509910235413, 0.004782064949975462],
    [1.0640963697177195, 0.006967742042369052],
    [1.0673282022973782, 0.006832719519286989],
    [1.0705625787796456, 0.008452989796273513],
    [1.0737956833106086, 0.009195613673225633],
    [1.0770285334513108, 0.009762708270171006],
    [1.0801393936776804, 0.01063022798097446],
    [1.0834966602244345, 0.012571176750281188],
    [1.0867301561250295, 0.013583845673398098],
    [1.0899638477104407, 0.01473153711959685],
    [1.09319714792622, 0.015609183519631475],
    [1.0964314265660793, 0.017161942535076857],
    [1.0996640418850023, 0.01756701010432349],
    [1.1028981248400456, 0.01898474659668703],
    [1.106131914267865, 0.020199949304427145],
    [1.1093660950653164, 0.021685197058331607],
    [1.1125156421798212, 0.022697865981448295],
    [1.1158327933392826, 0.023508001119941557],
    [1.1190654575794095, 0.02394682431995876],
    [1.1222996872980648, 0.025465827704633792],
    [1.1255331831986601, 0.02647849662775048],
    [1.1287669726264795, 0.027693699335490596],
    [1.1320013491087468, 0.029313969612477342],
    [1.135234551482118, 0.030124104750970604],
    [1.138239806411328, 0.03133430662452219],
    [1.1415051192134975, 0.031774380033086524],
    [1.144788353845784, 0.033317387421865075],
    [1.1481689264541308, 0.034444825489601705],
    [1.1514031072515822, 0.035930073243506166],
    [1.154473412886961, 0.03697274717175225],
    [1.157869945300417, 0.03784932196446067],
    [1.161104084165408, 0.03930563632056172],
    [1.1643379714356352, 0.04058835028984298],
    [1.1675712716514144, 0.04146599668987738],
    [1.1708051589216417, 0.04274871065915864],
    [1.1740393397190931, 0.0442339584130631],
    [1.1773470653932474, 0.04578109149004672],
    [1.1805071142595476, 0.046799386351625394],
    [1.1836807501749098, 0.04705592914548151],
    [1.1869733233214739, 0.048284634105529856],
    [1.1902076998037412, 0.0499049043825166],
    [1.1934412935467444, 0.05098508456717421],
    [1.1967122386290134, 0.0524956490441566],
    [1.198879301203279, 0.05258847702877567]])

data_mu5 = np.array([
    [1.0073775497661501, -0.0009085718040939827],
    [1.0106111108950175, 0.00014910462671680058],
    [1.0138434979149882, 0.00039664591903409985],
    [1.0170771242721275, 0.0014993298575385339],
    [1.0203128062516678, 0.004020393252802901],
    [1.0235427136654693, 0.0025570062883497613],
    [1.0268251553859873, 0.003552904556813452],
    [1.030008880794935, 0.004013320644450813],
    [1.0331675656138228, 0.004090422791559911],
    [1.0364708658603317, 0.002584010792965996],
    [1.0397048668141187, 0.003945166418514168],
    [1.0429374047909477, 0.00429686794292361],
    [1.0461172108349266, 0.008810799482441345],
    [1.0494184430346014, 0.016014251088878106],
    [1.0525371404378543, 0.018910484208991774],
    [1.0558911096954575, 0.021955242104495953],
    [1.0591275408682936, 0.02499324887384602],
    [1.062364754780394, 0.028571345735525],
    [1.0656011859532302, 0.031609352504875066],
    [1.0688391826045947, 0.03572753945888274],
    [1.0720760051470628, 0.039035591274397374],
    [1.075312338477491, 0.0420060867822063],
    [1.0785505308136716, 0.04625929625929648],
    [1.0817864727744675, 0.04895974672094083],
    [1.0850237845289759, 0.052605354844160956],
    [1.0882603135442201, 0.055710872875052164],
    [1.0916162690027063, 0.060126109379840864],
    [1.0947354262652769, 0.06333964542919779],
    [1.0979724444925614, 0.06678271976779449],
    [1.1012100497742938, 0.07063086167563792],
    [1.1044479485832503, 0.07468153736810468],
    [1.1076852603377587, 0.0783271454913248],
    [1.110922572092267, 0.0819727536145447],
    [1.1141595903195514, 0.08541582795314151],
    [1.117398076182956, 0.0898715712148549],
    [1.1206353879374644, 0.09351717933807491],
    [1.123873482431237, 0.09770287755362395],
    [1.1271116747674177, 0.10195608703071402],
    [1.1303491822067422, 0.1057367176770162],
    [1.1336451211321426, 0.10928781003407873],
    [1.1368249798246552, 0.11383806906194982],
    [1.1399152344398937, 0.11738241029285812],
    [1.143463565466774, 0.12163186914430701],
    [1.146538089197077, 0.12558502857010323],
    [1.1497765750604816, 0.13004077183181673],
    [1.152753419453434, 0.1341739612883892],
    [1.156253155417659, 0.13868221330907915],
    [1.159491132500542, 0.1427868980107787],
    [1.162468518288152, 0.14729364978121207],
    [1.166645819450816, 0.15302835638656542],
    [1.1697966972220704, 0.15785541158675498],
    [1.172740644823167, 0.16181607226383354],
    [1.1765698379179885, 0.1683871683871685],
    [1.1798092043630655, 0.17345051300275194],
    [1.183050136286671, 0.1795940378029931],
    [1.1861434631535215, 0.1852582326462925],
    [1.1899729269456718, 0.19201610992655782],
    [1.1932730828788582, 0.19847693765604224],
    [1.1966030709622533, 0.2052483171886158],
    [1.1991034336994753, 0.2072398994040786]])

data_mu8 = np.array([
    [1.006501087259253, 0.002541253660656606],
    [1.009730366152062, 0.0006441872113513991],
    [1.0129634576373707, 0.001377809586764922],
    [1.0161955119931543, 0.00139581258984256],
    [1.0194310374248416, 0.0038088579666406552],
    [1.0226637599044972, 0.004287866441384791],
    [1.0260340052287564, 0.006087029196755633],
    [1.02900686970555, 0.007721617796244695],
    [1.0323724365499187, 0.01297624431952804],
    [1.0356133684735243, 0.019119769119769314],
    [1.0387772617311066, 0.022790693966067144],
    [1.0420902423579257, 0.027963744381654942],
    [1.0453296088030026, 0.033027088997238385],
    [1.048569855829752, 0.03869803496669166],
    [1.0517114885805852, 0.04390390335663996],
    [1.0550499585136184, 0.04976988185943432],
    [1.0582904990675919, 0.05564336161351091],
    [1.0615320180456456, 0.062191953982998927],
    [1.0647732434964752, 0.0685380125678634],
    [1.068015056001753, 0.07528913872197462],
    [1.0712566728222146, 0.08190524235300367],
    [1.0744983874850844, 0.08858885724557375],
    [1.0778149271294954, 0.09621762979971948],
    [1.0809827952349043, 0.10263119964612522],
    [1.084224607740182, 0.10938232580023632],
    [1.0874674965119482, 0.11687607583129977],
    [1.0907101602461757, 0.12421454996081871],
    [1.093952393473808, 0.13125597453955673],
    [1.097367191356484, 0.13910415869371107],
    [1.1004376818053, 0.14590591829397814],
    [1.1037098450255491, 0.15332540593734645],
    [1.1069228722943842, 0.1604883507868583],
    [1.110253760527933, 0.16788083392561015],
    [1.1134086172237805, 0.17545334709513827],
    [1.1166510493976425, 0.18263204457234306],
    [1.1198924705332882, 0.18911312568028993],
    [1.1231373813814869, 0.19800210844986976],
    [1.1263789982019485, 0.2046182120808988],
    [1.1296214956040826, 0.2118419170657978],
    [1.1329531535312414, 0.21976548879533975],
    [1.1361667058876663, 0.22729074408178895],
    [1.1393512708000053, 0.23508829478978743],
    [1.1425937542246525, 0.242302355308752],
    [1.1458373418707617, 0.25027832863653776],
    [1.149301892617921, 0.2586666028830209],
    [1.1523237064687422, 0.2656708962679113],
    [1.1555671822949565, 0.2735697138682214],
    [1.1588090926426422, 0.28038835128387374],
    [1.1620529598384888, 0.2885572139303484],
    [1.165296435664703, 0.29645603153065847],
    [1.168539226594061, 0.3038822703001809],
    [1.1717828328768194, 0.31187110291587905],
    [1.1747313790710936, 0.31900479288538997],
    [1.1785645706589898, 0.3283348492303717],
    [1.1816760483796678, 0.3352600044142334],
    [1.1849617225493279, 0.3429915441109471],
    [1.188294587199519, 0.3517477547328295],
    [1.1915382489263087, 0.35977484373006763],
    [1.1944869679755035, 0.3670278035949678],
    [1.1988087758520016, 0.3756092350619714],
    [1.200385267087084, 0.3821278224263299]])

data_mu10 = np.array([
    [1.0114936494154534, 0.0008917285036689204],
    [1.0147260364354243, 0.0011392697959864417],
    [1.0179600215480595, 0.002489495026808619],
    [1.021196225353776, 0.005370618483625078],
    [1.0244309074770896, 0.0072017810823779005],
    [1.0275230354483005, 0.01203873793426058],
    [1.0308345495804938, 0.023440489858400415],
    [1.0341587453933334, 0.029111435827853915],
    [1.0372512503839564, 0.03420853607420793],
    [1.0405421145497935, 0.04101592161293666],
    [1.0444118665841573, 0.048541176899385974],
    [1.0477134412322602, 0.05598091792121651],
    [1.0509563300040263, 0.06347466795228007],
    [1.054111610683642, 0.07133972992181958],
    [1.0574447492925754, 0.08028497207601692],
    [1.0606889100156458, 0.08865636850711489],
    [1.0639331685811244, 0.097095276199754],
    [1.0671768400921549, 0.10512911632314625],
    [1.0704223706089377, 0.11444567041581977],
    [1.0736673140712725, 0.12335715693924654],
    [1.0766173713871818, 0.13153352083700365],
    [1.0801573184068316, 0.14126114349994967],
    [1.0834023401430928, 0.15022663903260935],
    [1.0866474792902436, 0.1592731480791184],
    [1.0899810973269766, 0.16854919541486724],
    [1.0931376597421374, 0.17729865491059538],
    [1.0963827988892882, 0.18634516395710432],
    [1.09950876734238, 0.19763736010626565],
    [1.1028744958985062, 0.20541709534246855],
    [1.1061181184883326, 0.21341717983509034],
    [1.1093660950653164, 0.22442151546629174],
    [1.1126996837493268, 0.23367730942357812],
    [1.1159553898765449, 0.24325715743626197],
    [1.1191030779852973, 0.25264122279047674],
    [1.1226439947319247, 0.26303795706780797],
    [1.1258890360366673, 0.2720169548527759],
    [1.1291343708686343, 0.281198486422367],
    [1.1323806841246815, 0.29105513060736943],
    [1.1356264103262805, 0.3005067072231252],
    [1.1388717451582473, 0.30968823879271656],
    [1.1410843289128494, 0.315848641408343],
    [1.1450683983860492, 0.32791627940881685],
    [1.1489621152875533, 0.3384615384615386],
    [1.15191835624365, 0.3463993625685169],
    [1.1553940990751503, 0.35687861060995396],
    [1.1588614624032771, 0.36720756572391267],
    [1.1622378624211849, 0.37559273230915036],
    [1.1654250984312633, 0.38523334045722113],
    [1.169083347793601, 0.3954950522114702],
    [1.17235831909096, 0.4048521130610684],
    [1.1756505106521329, 0.4125754013813716],
    [1.1792881299427374, 0.42211811820020784],
    [1.1827640342142107, 0.4327087598231878],
    [1.1860009654704657, 0.44172338855174687],
    [1.1888770724072475, 0.44955807045359286],
    [1.1923111158915831, 0.45861808175241014],
    [1.1958411503881616, 0.467942137096366],
    [1.1990092603817457, 0.4753271189838355]])

data_mu15 = np.array([
    [1.0125136715682665, 0.005266715437291181],
    [1.0154963119746347, 0.011307430230671045],
    [1.0188868555008868, 0.02028021269314828],
    [1.0221094854585013, 0.02731113552009079],
    [1.025354102779476, 0.03599758450504731],
    [1.028599926823483, 0.04551667238234414],
    [1.0318469738975904, 0.05587965102890491],
    [1.0350937763656778, 0.06607385152161294],
    [1.0383415083366414, 0.07690940899896137],
    [1.041120356658427, 0.08859335799634316],
    [1.0442511636903806, 0.09984523491986197],
    [1.0475004019685117, 0.11172014434274558],
    [1.0507529156377307, 0.1258550736162678],
    [1.0540050015958518, 0.13969488223219573],
    [1.0572567940267485, 0.15333215706350056],
    [1.0603487847175346, 0.16587194113026482],
    [1.0637607702581746, 0.18087675177227425],
    [1.0669649475647243, 0.1954489772053738],
    [1.070264187390126, 0.20803556784367017],
    [1.0735181043990258, 0.2231388014970106],
    [1.076770777411595, 0.23738367768218516],
    [1.079769906267156, 0.2504570727385228],
    [1.0832755363822852, 0.265468362483288],
    [1.0865277201828143, 0.27937568236075716],
    [1.0898030584071237, 0.2936644532306334],
    [1.093031500729424, 0.30678525454644867],
    [1.0962809798862454, 0.3188263702656028],
    [1.0992560533937346, 0.33074815179292805],
    [1.1027853125435865, 0.3466168988557049],
    [1.1060367136048512, 0.35998412864084506],
    [1.1092875276116678, 0.3729462908567387],
    [1.1125385373033003, 0.3860434755957145],
    [1.1157899090118428, 0.3993904520023924],
    [1.1190378395213594, 0.41036300108128476],
    [1.1222881698488911, 0.4229914245905717],
    [1.1255389559007338, 0.4359342978745965],
    [1.1287887914834702, 0.4482213474750789],
    [1.1320379747834863, 0.4600583219986206],
    [1.1352866036431903, 0.47151273270676264],
    [1.1385344588489963, 0.4824333222254332],
    [1.1419111373295034, 0.49535497768440195],
    [1.145032685907118, 0.5060109873542711],
    [1.1482770935657898, 0.5145527693502109],
    [1.1515859778182995, 0.5193128490925222],
    [1.1547746914040447, 0.5376962727708997],
    [1.1580444466975441, 0.5481328213819604],
    [1.1612684104896953, 0.5581634368947802],
    [1.1645148705093546, 0.5681213479720943],
    [1.1677606945533616, 0.5776404358493912],
    [1.1710067795104566, 0.5873395537574644],
    [1.1742521469565597, 0.5965435890809025],
    [1.1775709497502254, 0.6057339346207506],
    [1.1807404684027007, 0.6132863819430985],
    [1.1839843821901699, 0.6214873928093545],
    [1.1872302574849622, 0.6310418437284109],
    [1.190474907420073, 0.6397507964672144],
    [1.1937198508824076, 0.6486622829906412],
    [1.1969647943447423, 0.657573769514068],
    [1.1996151215385014, 0.661672667536207]])

data_mu20 = np.array([
    [1.014577903029666, 0.017190072227385667],
    [1.0182174481850017, 0.032669279311070554],
    [1.021384417305047, 0.04833607125718009],
    [1.0206588086887676, 0.040025756443667015],
    [1.0246078587334266, 0.05557585035196988],
    [1.0277562317390352, 0.07157601933721347],
    [1.0308625325091905, 0.08619220746086431],
    [1.0339113084662512, 0.10166353823070262],
    [1.037079370625769, 0.11834782133289601],
    [1.0403366821838322, 0.13579329390896566],
    [1.0430029978753752, 0.15092425540186738],
    [1.045964811500178, 0.16721247243635307],
    [1.0487784232295372, 0.18260954081849612],
    [1.0518885105008835, 0.19983841476378794],
    [1.0551148140526558, 0.21036952859980595],
    [1.0575772964027343, 0.23256337360814971],
    [1.0605069153093163, 0.24691086691086706],
    [1.0631455494267792, 0.26321517412935336],
    [1.0662563930742963, 0.2809659476326144],
    [1.0689237401878904, 0.29680859034092877],
    [1.0717377345897787, 0.3124697027682104],
    [1.0745527335070562, 0.32882393081398065],
    [1.0775112732161727, 0.3428531460247879],
    [1.0803289242062766, 0.36103730432088654],
    [1.0831410211902075, 0.37538919835768925],
    [1.0861028884471453, 0.3917144215651679],
    [1.0891725655809448, 0.4064023404042062],
    [1.092613358153051, 0.42373951366488694],
    [1.0957504238377047, 0.43930986095165203],
    [1.098628456095649, 0.4518519530957342],
    [1.1005107863911672, 0.46666317375272615],
    [1.1032657187670165, 0.47536087461460597],
    [1.1065194680460742, 0.490348374676733],
    [1.1083032888968274, 0.5047668512487277],
    [1.1113667922795112, 0.5101264738578172],
    [1.1142032678952547, 0.5210259920044332],
    [1.1172237699330496, 0.5372619503216519],
    [1.1204149489921715, 0.5496232623098295],
    [1.123665371629356, 0.5623153794795587],
    [1.12691432663042, 0.573994827726171],
    [1.1302521910276615, 0.5862008638128042],
    [1.1335116880046219, 0.5983963981476419],
    [1.136660995948796, 0.6088981499429261],
    [1.1397602136274845, 0.6186270049542971],
    [1.14370907381128, 0.6317422730669],
    [1.1469086603287493, 0.6419400902343334],
    [1.1502986230127696, 0.6524429136369436],
    [1.1534857807489214, 0.6620295127757815],
    [1.1567314091081125, 0.6714135781299961],
    [1.1600851859423134, 0.6878413184383334],
    [1.1597468795094794, 0.6796724557918589],
    [1.163221002505558, 0.6890340173922265],
    [1.1664653589134446, 0.6975404363464066],
    [1.169709389179971, 0.7058218177621163],
    [1.172951690897289, 0.7129105002239331],
    [1.1769065136440218, 0.7216925901627395],
    [1.1797014979907883, 0.7298683289562229],
    [1.1832712307760977, 0.737621872323365],
    [1.186513855373362, 0.7449333419482673],
    [1.1898740180553937, 0.7522515626993239],
    [1.19299836096559, 0.7590431956103598],
    [1.1964035594209002, 0.7658993392824239],
    [1.1992710442672587, 0.7689110916722858]])

data_mu30 = np.array([
    [1.0095873958358186, 0.020257521408019175],
    [1.0116626558682582, 0.04148006153603179],
    [1.0149659419431483, 0.039963871120587635],
    [1.0178091974760803, 0.06429605496769708],
    [1.0203037432491868, 0.0846539151443203],
    [1.0235469877479937, 0.106874282433984],
    [1.0257766095931635, 0.12479096754150065],
    [1.0277087129428681, 0.1401562091860601],
    [1.0296424306923055, 0.15663538664604781],
    [1.0317240069569262, 0.17376878037858856],
    [1.0337342895355819, 0.1923936103973417],
    [1.0362647752712182, 0.2079294787183913],
    [1.0378202366007903, 0.22407270728166262],
    [1.0400504600732328, 0.24240451520716877],
    [1.0424287072022773, 0.26150448698423134],
    [1.044509899086009, 0.2783726579035748],
    [1.0465903222079638, 0.2947103831965241],
    [1.048521111829209, 0.3091691522039782],
    [1.0507506217768312, 0.32700862800365305],
    [1.0532771812752344, 0.34707597543418456],
    [1.0553577748060496, 0.36353128284098446],
    [1.0575861269130173, 0.38057184858890636],
    [1.0597672635223407, 0.3988231073637377],
    [1.0621011673331595, 0.414357698686057],
    [1.0644197836042186, 0.4328596421346955],
    [1.06649786969037, 0.44758481272340556],
    [1.0688722787050593, 0.46403648559535804],
    [1.0715431336501708, 0.4822995320507759],
    [1.0741429663961157, 0.5022413406830607],
    [1.0776814760642002, 0.5143561294058807],
    [1.079847605874176, 0.5357684511913369],
    [1.0809654282074788, 0.5468046671404881],
    [1.0834040686923014, 0.5568919748024226],
    [1.0862186849370496, 0.5729821588030544],
    [1.0890312682339864, 0.5876696088138875],
    [1.0901292095335464, 0.6018826046811122],
    [1.0928802689807449, 0.6079079847736565],
    [1.0961354532817869, 0.623885650005053],
    [1.0993375482922314, 0.6370210911255689],
    [1.1007988670545452, 0.6485441382829443],
    [1.103526273099602, 0.655143364098588],
    [1.106777478476051, 0.6683755713606461],
    [1.1100278032708273, 0.6810001772688341],
    [1.1132767908860273, 0.6927021292692934],
    [1.1165238542672027, 0.7030763597927778],
    [1.1197707708847662, 0.7133493234239503],
    [1.1230596754845978, 0.7188046084190363],
    [1.1262639681442406, 0.7334564274862783],
    [1.1295094986610237, 0.7427729815789518],
    [1.1328724694201657, 0.7520287755362383],
    [1.135999483428101, 0.7606634658873466],
    [1.1391929898682067, 0.7678727934739544],
    [1.1405308588712222, 0.7786889727188235],
    [1.1427149623315533, 0.7764611010879667],
    [1.1460605815549845, 0.7844443077652034],
    [1.149266718272234, 0.7919211799808815],
    [1.1509359880271626, 0.803325519836714],
    [1.153984307386319, 0.8032765741720966],
    [1.1573002609857672, 0.8105009757017576],
    [1.1604639012896638, 0.8139973625048252],
    [1.163674295510585, 0.8215961300538416],
    [1.1669488960939318, 0.8284447724746233],
    [1.170189240963089, 0.8341832297056179],
    [1.1734289009353902, 0.8394491081058246],
    [1.1766681695380592, 0.8444449414598669],
    [1.180131008043078, 0.8516517686293806],
    [1.1789467920259613, 0.845487990450677],
    [1.1831460218465408, 0.8539640293371638],
    [1.1864723701923572, 0.8582239899404079],
    [1.1896224065189023, 0.8624704482913439],
    [1.1928600118006347, 0.8663185901991872],
    [1.1958036006462351, 0.8700317095839485],
    [1.1991853495377542, 0.8719707830404348]])

data_mu40 = np.array([
    [1.0063738096735872, 0.023885429463309293],
    [1.0083211093350612, 0.041938575520665156],
    [1.0094851295920226, 0.056693536793039456],
    [1.0110074704899494, 0.07090090672180238],
    [1.012817633312442, 0.08322171195305539],
    [1.015821136568115, 0.09786532652670721],
    [1.017997895519895, 0.10659804267316175],
    [1.0194707898633921, 0.13260619977037902],
    [1.021855975779294, 0.15649393447900928],
    [1.0239405604650034, 0.17570313876284038],
    [1.02527706819022, 0.18558003632630504],
    [1.0273692405546722, 0.2100247389426495],
    [1.0288606768408846, 0.22543418438940832],
    [1.030353673713505, 0.24192043445774802],
    [1.0318458095729348, 0.2578125854245258],
    [1.0333385911922577, 0.274150310717475],
    [1.03487526032322, 0.29180808784068013],
    [1.0364724998285457, 0.307815926472643],
    [1.0383612398889275, 0.32704988488570585],
    [1.0397578750352923, 0.3446253166402421],
    [1.0414368843904251, 0.3627499806371076],
    [1.0437800366545615, 0.382976535428561],
    [1.0449829946955473, 0.40207231007693],
    [1.0475039443295986, 0.41826885110467205],
    [1.04929305798871, 0.4363393654438431],
    [1.05107924181127, 0.4523882925624221],
    [1.0528642895747589, 0.4676533389219957],
    [1.0549469549185642, 0.4855381972919287],
    [1.0565637843653755, 0.5029954575485849],
    [1.0612777038844166, 0.5399766531607328],
    [1.0598580127181685, 0.529018825287482],
    [1.0637174120939301, 0.5564322552595474],
    [1.0659445149630093, 0.5726108468645783],
    [1.0683172789698585, 0.587927464326718],
    [1.0720260783405207, 0.6127950499841048],
    [1.074693963587359, 0.6290090046308953],
    [1.0776552727801916, 0.6449491636058801],
    [1.0803246093560823, 0.6621645352988638],
    [1.0835780651079159, 0.6769495015763674],
    [1.0868325971262376, 0.6924770917308232],
    [1.0900852701388068, 0.7067219679159977],
    [1.0935196836271874, 0.7160372820059083],
    [1.09658689815244, 0.732646292347785],
    [1.099675120656127, 0.7425860273162226],
    [1.1008266706054939, 0.7522020544408605],
    [1.1036752870870328, 0.757963015425702],
    [1.106922285239936, 0.7682922384414923],
    [1.1101684028111671, 0.7780138601034123],
    [1.1134136398007262, 0.7871278804114625],
    [1.1166582897358368, 0.7958368331502661],
    [1.1198513400310124, 0.8027314207351521],
    [1.1231448500186332, 0.8113644233047219],
    [1.1263832576081116, 0.8157661575572024],
    [1.129346936557656, 0.8206704287627795],
    [1.1328727335946673, 0.8333055833055834],
    [1.1361137633606808, 0.8395166193673658],
    [1.139240249772247, 0.844668247940349],
    [1.1425938660445474, 0.8505884662601081],
    [1.1458333303320325, 0.8557193221372327],
    [1.1490723054074774, 0.8605126217066517],
    [1.1523110847981062, 0.8651708987529884],
    [1.1555493749766947, 0.8694916194916196],
    [1.1586755620072176, 0.8744366751446737],
    [1.1620256291925122, 0.8779080234304115],
    [1.1652625821915243, 0.8813060902613141],
    [1.168500578842889, 0.885424277215322],
    [1.1717377927549892, 0.889002374077001],
    [1.1749760242281333, 0.8932825880587075],
    [1.1782166332717923, 0.899203325695863],
    [1.181450262890345, 0.9003082600097526],
    [1.184686785382762, 0.9034092772898743],
    [1.1879213184128823, 0.9051375655853269],
    [1.1911568690040462, 0.9075679710008069],
    [1.1943915390135376, 0.9093907750624168],
    [1.1976262090230292, 0.9112135791240269]])

data_mu50 = np.array([
    [1.0062473354718542, 0.03018883876352496],
    [1.0180125324813118, 0.15135332697521753],
    [1.0187880333098536, 0.16834497384870528],
    [1.0208177822179823, 0.2004015712038102],
    [1.019835375136316, 0.18143371967998845],
    [1.0228281647356692, 0.2190953591539947],
    [1.0241753874625386, 0.2363656078581453],
    [1.025672560249134, 0.2557332385690595],
    [1.0270213912256416, 0.27411317952362735],
    [1.0282213745468125, 0.29115639749968114],
    [1.029567374942456, 0.30758323765786466],
    [1.0309136551673865, 0.3242031600240557],
    [1.0321126160353935, 0.34054088531700477],
    [1.0334627615945406, 0.3598278882927072],
    [1.0348102267376238, 0.3772654041843808],
    [1.0361573331252112, 0.39445537878373704],
    [1.0391466274210164, 0.42970525880973665],
    [1.041577007560541, 0.45943496801705763],
    [1.0401977989623998, 0.445436507936508],
    [1.0436251157811833, 0.478817451205511],
    [1.045266475989221, 0.4963062435077361],
    [1.046903294352678, 0.5106611630492228],
    [1.0486979287463667, 0.5325409842467413],
    [1.0504833010981616, 0.5480299965374593],
    [1.0522705492286932, 0.5648132961565798],
    [1.0544043372306946, 0.5841834022804173],
    [1.0564363155479777, 0.6008835987514026],
    [1.058673557530721, 0.6127950499841048],
    [1.061230064144162, 0.6394469957902794],
    [1.0600038827028877, 0.6296691147437417],
    [1.0637114637996776, 0.6536960914293004],
    [1.066233632031154, 0.6707334646803969],
    [1.06890101900647, 0.6866036119767464],
    [1.0717153482468214, 0.7024957629435242],
    [1.074823468885766, 0.7183676605318396],
    [1.0780782998670013, 0.7341015350965601],
    [1.08074223744446, 0.7475915978714487],
    [1.0836961608944087, 0.7584355942564898],
    [1.0869464856891853, 0.7710602001646778],
    [1.0901928967876404, 0.7809843556112213],
    [1.0932107697636935, 0.7909010098064825],
    [1.096686403881407, 0.8013052453350962],
    [1.0998218413053207, 0.810683684750849],
    [1.1040240341201568, 0.821204189674339],
    [1.107305240424968, 0.8297949977054455],
    [1.110548618408774, 0.8376263040442146],
    [1.1137914093381323, 0.8450525428137369],
    [1.1170325369465537, 0.8513310901370603],
    [1.1201991265778308, 0.8568625128326621],
    [1.1235138137393166, 0.8632130721682961],
    [1.1266066611783678, 0.868546461830044],
    [1.129993427211143, 0.873947362753333],
    [1.133232891498628, 0.8790782186304575],
    [1.1364702032531364, 0.8827238267536776],
    [1.1396279886983975, 0.8867880046984525],
    [1.1429467836103138, 0.8913652682309399],
    [1.14618419320723, 0.8950783876157011],
    [1.1494206243800662, 0.8981163943850512],
    [1.1526578382921666, 0.9016944912467301],
    [1.1557461458434852, 0.9038953583729703],
    [1.1591291351593103, 0.9066903246007724],
    [1.1623344752762879, 0.9085491346685377],
    [1.165600236341638, 0.9115511354317325],
    [1.168650607945303, 0.91291823847794],
    [1.1723654518025057, 0.9166144800473159],
    [1.1756003174968133, 0.9185723066320082],
    [1.178835672403161, 0.920867689524406],
    [1.1820707337822847, 0.9229605386321804],
    [1.1853051102645522, 0.9245808089091672],
    [1.1885383126379232, 0.9253909440476605],
    [1.1917724934353746, 0.926876191801565],
    [1.1950046195422575, 0.926943703063106],
    [1.1982414518689664, 0.9302585060047747],
    [1.2001474121931617, 0.9275850600477467],
    [1.0161384509210596, 0.13553113553113572],
    [1.0146626320539365, 0.11721611721611735],
    [1.0131868131868131, 0.098901098901099],
    [1.0109863566385306, 0.08058608058608063],
    [1.0095158464723681, 0.06593406593406603],
    [1.0080453363062059, 0.05128205128205132],
    [1.0375510962467485, 0.41025641025641035]])

data_mu75 = np.array([
    [1.0060525527343225, 0.05797780459294344],
    [1.0056153450988283, 0.03337750459285638],
    [1.0069515470276933, 0.08165984427533823],
    [1.0084048061769508, 0.09968939642447117],
    [1.0095564536013688, 0.1239281093225657],
    [1.0111112486707339, 0.14250785146307543],
    [1.0120177725586241, 0.1598003788835347],
    [1.013073260056753, 0.17850963816448906],
    [1.0145443952663291, 0.20018497257303236],
    [1.0151851191290544, 0.21653816919675128],
    [1.0162416914354688, 0.23599594619495123],
    [1.017666928790851, 0.2564122089708445],
    [1.0183507193289802, 0.2720709638620087],
    [1.0192588729918386, 0.2904880360104243],
    [1.0213240370466918, 0.3368442686850648],
    [1.0201017331544047, 0.30439985663866265],
    [1.0209180992235827, 0.3203043846700564],
    [1.0228769939212292, 0.35415565639446245],
    [1.0240065131785199, 0.3732627498952127],
    [1.0246874535323593, 0.3869548776265195],
    [1.0257418701026233, 0.4049251966807049],
    [1.0269152892876665, 0.4239127925695091],
    [1.0278528429634313, 0.44234224178254045],
    [1.0290573570675552, 0.4625116999961528],
    [1.0302601222386354, 0.48147439440971795],
    [1.0323259084780205, 0.5079863025705244],
    [1.0310078284851159, 0.4905509084613563],
    [1.0335641407726635, 0.5311476804014118],
    [1.0347631913295443, 0.5475472910174404],
    [1.0359626903307955, 0.5642563282488656],
    [1.037157991892742, 0.5780691323601772],
    [1.0386219833835018, 0.5948153007854501],
    [1.039850600518341, 0.6113422183518133],
    [1.0415310778881512, 0.6304798124760811],
    [1.0437246345558049, 0.6488535648983411],
    [1.045512851326176, 0.6663052260067186],
    [1.0472995613234635, 0.6827172136873629],
    [1.0490864148229495, 0.6992282178849344],
    [1.0511637885231873, 0.7134618421931855],
    [1.0533947352011535, 0.7322926619301886],
    [1.055769391927971, 0.748915256170646],
    [1.0585825395529977, 0.7639920925635212],
    [1.0608957980669764, 0.7787971836266079],
    [1.0640585047058115, 0.7917861574577993],
    [1.0673102971367086, 0.805423432289104],
    [1.0706173411754203, 0.8166370528310828],
    [1.0738079136116125, 0.8285797949977055],
    [1.0769559169903462, 0.8381813966391081],
    [1.0802016676525472, 0.8476498510702491],
    [1.083543820265105, 0.8560568784449382],
    [1.0867874917761355, 0.8640907185683305],
    [1.0900297934934535, 0.8711794010301473],
    [1.0932714103139152, 0.8777955046611764],
    [1.0965124400799287, 0.8840065407229587],
    [1.099753176318718, 0.8900150430001177],
    [1.1029930319758354, 0.8954159439234066],
    [1.1062324147279803, 0.9004905404159136],
    [1.109470590757093, 0.9047324980160801],
    [1.1127072176147452, 0.9079055273085124],
    [1.1159439423148054, 0.9111460678624859],
    [1.1191827217054342, 0.9158043449088226],
    [1.12251642997461, 0.9183847753499496],
    [1.12565392073017, 0.9207326670013237],
    [1.1288899605333738, 0.9235006287245093],
    [1.1321255111245376, 0.9259310341399893],
    [1.1353607681884774, 0.9281589057708461],
    [1.1385967101492733, 0.9308593562324906],
    [1.141831478001173, 0.9327496715556418],
    [1.1450663436954807, 0.934707498140334],
    [1.1485220030138104, 0.9369606864942687],
    [1.151537151350584, 0.9393657751866707],
    [1.1547716256752596, 0.9410535567251985],
    [1.158005806472711, 0.942538804479103],
    [1.1612406721670185, 0.9444966310637953],
    [1.164474755122062, 0.9459143675561587],
    [1.1677086423922893, 0.9471970815254398],
    [1.1709426275049246, 0.948547306756262],
    [1.1741750471390315, 0.9488173518024264],
    [1.1774086408820348, 0.9498975319870843],
    [1.1806428216794862, 0.9513827797409887],
    [1.1838764154224894, 0.9524629599256466],
    [1.187111378959205, 0.9544882977718799],
    [1.1903759887455538, 0.9544432902641858],
    [1.193576968352547, 0.9555459742026907],
    [1.196809811970422, 0.9561085680488666],
    [1.1993078346433852, 0.9564855059258045]])

data_mu100 = np.array([
    [1.0058814306335757, 0.08181897796325666],
    [1.0074088321582733, 0.122044437964836],
    [1.0081741831959043, 0.14329585791028587],
    [1.008860326999252, 0.1605783658022466],
    [1.0096991870380363, 0.1818669169415439],
    [1.0104800978140414, 0.19937339076464888],
    [1.0113728412199823, 0.22163855124054144],
    [1.0119122899009696, 0.23906958390789246],
    [1.0125980595735857, 0.25609394159500776],
    [1.0133556230544116, 0.2719719473450818],
    [1.014119270003436, 0.2920475461520239],
    [1.0150527374541003, 0.3076575000455598],
    [1.0157879853180525, 0.32841136199345156],
    [1.018341273199147, 0.38140245908166526],
    [1.0189746886694022, 0.39850533114125875],
    [1.0207471635238397, 0.4388844566567066],
    [1.0197838866044593, 0.41622172390947565],
    [1.021858803968455, 0.46254986261205167],
    [1.0229390586220566, 0.47807482732855877],
    [1.0238484272701953, 0.4973302393202892],
    [1.0248221163939972, 0.5136616385579903],
    [1.0257868597501951, 0.5373362127093471],
    [1.0266942292760406, 0.5552122303188403],
    [1.0277467025873672, 0.5718417007063064],
    [1.0289507244704086, 0.591671526373019],
    [1.030302281988687, 0.6119327811491991],
    [1.031799745367234, 0.6315009203068904],
    [1.0332967890018507, 0.6507794361525705],
    [1.0347913356982144, 0.6683350646037214],
    [1.0364336466083168, 0.6864798413305877],
    [1.0383714993642839, 0.705812173296182],
    [1.0413548914333037, 0.7369895168402631],
    [1.0438812313298578, 0.7569053389948913],
    [1.0459614302296272, 0.7730883509801421],
    [1.0480885364105135, 0.7878480005345677],
    [1.0509870416487692, 0.8055059460532098],
    [1.0546657802984862, 0.8237105452590527],
    [1.0578222905310295, 0.8363660938287805],
    [1.0607843552846796, 0.8471960253676671],
    [1.0642117259167876, 0.8569615293495891],
    [1.0673972790374477, 0.8654409437991528],
    [1.0707279813704214, 0.8727051555409765],
    [1.0738814911024515, 0.8793482636766219],
    [1.0771218653243313, 0.8851069742860789],
    [1.080450596132783, 0.8910108341078491],
    [1.0836019386554754, 0.8961585678003589],
    [1.0868408158885121, 0.9008843561082367],
    [1.0900781276430205, 0.9045299642314568],
    [1.0933141348320885, 0.9072754222007954],
    [1.0965529468368533, 0.9119562030009791],
    [1.0994379280800435, 0.9157773404042061],
    [1.1033805074801182, 0.9194904597889673],
    [1.1063075833227405, 0.9233945395992305],
    [1.1097363992269897, 0.9259512875184517],
    [1.1130018993792516, 0.9287732582508702],
    [1.116385573591933, 0.93204080330946],
    [1.1194788172927368, 0.9342686749403167],
    [1.1227396846069786, 0.9372729260788962],
    [1.1259757244101825, 0.9400408878020818],
    [1.1290998324985995, 0.9416020857252201],
    [1.132446238538062, 0.9444966310637953],
    [1.1357923265896983, 0.9471717648023619],
    [1.1387987155848933, 0.9486013157654949],
    [1.142150424682871, 0.9500865635193994],
    [1.1454699995385542, 0.9525690490509254],
    [1.1490912672661537, 0.9546908315565032],
    [1.1521485685583674, 0.9557710117411611],
    [1.1553824558285946, 0.9570537257104421],
    [1.1586163430988219, 0.9583364396797233],
    [1.161850034684233, 0.9594841311259222],
    [1.1650003924929762, 0.9610561790732367],
    [1.1683173200126475, 0.9617120027567789],
    [1.1715501310163867, 0.9622520928491078],
    [1.1743421742022488, 0.9627668662183588],
    [1.1779177258023965, 0.9632722630235069],
    [1.1812497381365, 0.9646824982645879],
    [1.197417193178874, 0.969728965064786],
    [1.2001241648370136, 0.9723652798279664],
    [1.00515740298349, 0.05860805860805873],
    [1.0051680203854116, 0.06593406593406603],
    [1.005935127674258, 0.09523809523809523],
    [1.0066756914583002, 0.1062271062271063],
    [1.0164357381748685, 0.34065934065934067],
    [1.016456972978712, 0.3553113553113554],
    [1.0179221744439135, 0.36630036630036633],
    [1.040176248871901, 0.7216117216117217],
    [1.1847348303870042, 0.967032967032967],
    [1.1869087434304826, 0.967032967032967],
    [1.18980729415512, 0.967032967032967],
    [1.1927058448797578, 0.967032967032967],
    [1.1956043956043956, 0.967032967032967]])

mu_curves = {                  # Dictionary to access the curves
    'mu2': (1, 2, data_mu2),
    'mu5': (2, 5, data_mu5),
    'mu8': (3, 8, data_mu8),
    'mu10': (4, 10, data_mu10),
    'mu15': (5, 15, data_mu15),
    'mu20': (6, 20, data_mu20),
    'mu30': (7, 30, data_mu30),
    'mu40': (8, 40, data_mu40),
    'mu50': (9, 50, data_mu50),
    'mu75': (10, 75, data_mu75),
    'mu100': (11, 100, data_mu100)
}

ba_ratio_plot = np.linspace(1.0, 1.20, 1000)
indexes = np.array([entry[0] for entry in mu_curves.values()])
mu_values = np.array([entry[1] for entry in mu_curves.values()])
keys_list = list(mu_curves.keys())

# ============================
# Computed additional data
# ============================
t = 0.05                                    #m #First guess
R_int = D_vess_int/2                        #m
R_ext = R_int + t                           #m
R_barr_ext = D_barr_ext/2                   #m
v_flr = m_flr/rho                           #m³/s
G = E/(2*(1+nu))                            #MPa
rho_ii = (R_ext**2)/(R_ext**2 - R_int**2)
rho_i = (R_int**2)/(R_ext**2 - R_int**2)
P_int_MPa = P_int/10                        #MPa
P_cpp_MPa = P_cpp/10                        #MPa
Phi_0 = Phi_0 * 1e4                         #photons/(m²·s)
Mar_criterion = R_int/t

# ======================================
# Simpson composite integration function
# =====================================
def simpcomp(f, a, b, N):
    """ Formula di Cavalieri-Simpson composita
    Input:
        f:   funzione da integrare (lambda function)
        a:   estremo inferiore intervallo di integrazione
        b:   estremo superiore intervallo di integrazione
        N:   numero di sottointervalli (N = 1 formula di integrazione semplice)
    Output:
        I:   integrale approssimato """
    h = (b-a)/N                                     # Intervals width
    x = np.linspace(a, b, N+1)                      # Space grid
    xL, xR = x[:-1], x[1:]                          # Left and right nodes list
    xM = 0.5*(xL + xR)                              # Middle points
    I = (h/6.0)*(f(xL)+4*f(xM)+f(xR)).sum()         # Approximate integral
    return I

# =============================================================================================================================================================
# PURELY MECHANICAL PROBLEM
# =============================================================================================================================================================
dr = 100
r = np.linspace(R_int, R_ext, dr)

while True:
    try:
        Def_P_flag = int(input("\nAssume default pressures (75 bar = 7.5 MPa)? (1: Yes, 0: No): "))
        if Def_P_flag not in (0, 1):
            raise RuntimeError("Invalid input! Please enter either 0 or 1.")
        break  
    except ValueError:
        print("Please enter a valid integer.")
    except RuntimeError as e:
        print(e)

if Def_P_flag == 0:
    P_int = int(input("\nSet the internal pressure (bar): "))
    P_int_MPa = P_int/10
    P_cpp = int(input("Set the external pressure (bar): "))
    P_cpp_MPa = P_cpp/10
    
    while P_int != P_cpp: #Asks for this here, because asking for it in the sigmaL function would mean having to input the value for every iteration
        try:
            flag_eps = int(input("\nEnter the stress/strain condition (1: Plane Stress, 0: Plane Strain): "))
            if flag_eps not in (0, 1):
                raise RuntimeError("Invalid input! Please enter either 0 or 1.")
            break  
        except ValueError:
            print("Please enter a valid integer.")
        except RuntimeError as e:
            print(e)

# ============================
# Mariotte Solution for a thin-walled cylinder and sphere (R_int = R_ext = R)
# ============================
if Mar_criterion > 5:
    while True:
        try:
            Mariotte_flag = int(input("\nWith an initial thickness value of %.3f m, the vessel can be considered thin. Are you interested in visualizing the Mariotte solution for stress? (1: Yes, 0: No): " %t))
            if Mariotte_flag not in (0, 1):
                raise RuntimeError("Invalid input! Please enter either 0 or 1.")
            break  
        except ValueError:
            print("Please enter a valid integer.")
        except RuntimeError as e:
            print(e)

    sigma_rM_cyl = -P_int_MPa/2                        #Compressive
    sigma_tM_cyl = R_int*P_int_MPa/t                   
    sigma_zM_cyl = R_int*P_int_MPa/(2*t)
    sigma_tM_sph = R_int*P_int_MPa/(2*t)

    if Mariotte_flag == 1:

        # ======================================
        # Plotting the stress profiles: Mariotte
        # ======================================
        plt.figure(figsize=(15,10))
        plt.axvline(x = R_int, color='black', linewidth='3', label='Vessel Inner Surface')
        plt.axvline(x = R_ext, color='black', linewidth='3', label='Vessel Outer Surface')
        plt.axhline(y = sigma_rM_cyl, color='red', label='Radial (r) Stress Mariotte')
        plt.axhline(y = sigma_tM_cyl, color='blue', label=r'Hoop ($\theta$) Stress Mariotte')
        plt.axhline(y = sigma_zM_cyl, color='green', label='Axial (z) Stress Mariotte')
        plt.axhline(y = 0, color='black', linewidth='1', label='y=0')
        plt.xlabel('Radius (m)')
        plt.ylabel('Stress (MPa)')
        plt.title('Stress Distribution in a thin-walled cylinder - Mariotte Solution')
        plt.legend()
        plt.grid()
        plt.show()

    elif Mariotte_flag == 0:
        print("Skipping Mariotte solution.")
else:
    print("\nThe cylinder can't be considered thin. Skipping Mariotte solution.")
    Mariotte_flag = 0

# ============================ 
# General Lamé Solution 
# ============================
def sigmaL_func(r, P_int_MPa, P_cpp_MPa, verbose): #the "verbose" variable is used to avoid printing the hydrostatic stress condition information for every iteration of the thermal shield loop
    
    A = ((P_int_MPa*(R_int**2))-(P_cpp_MPa*(R_ext**2)))/((R_ext**2)-(R_int**2))
    B = (((R_int**2)*(R_ext**2))/((R_ext**2)-(R_int**2)))*(P_int_MPa-P_cpp_MPa)
    sigma_rL = lambda r: A + B/(r**2)
    sigma_tL = lambda r: A - B/(r**2)

    if P_int == P_cpp:
        if verbose:
            print("\nInternal and external pressures are equal: hydrostatic stress condition is verified. Skipping.")    #Hydrostatic Stress Condition
        eps_z_a = (2*nu-1)*rho_ii*P_cpp_MPa/E
        eps_z_b = (1-2*nu)*rho_i*P_int_MPa/E

    elif P_int != P_cpp:
        if flag_eps == 1:                                                                                           #Plane Stress
            eps_z_a = 2*nu*rho_ii*P_cpp_MPa/E
            eps_z_b = -2*nu*rho_i*P_int_MPa/E
        elif flag_eps == 0:                                                                                         #Plane Strain
            eps_z_a = 0
            eps_z_b = 0 

    sigma_zL_a = E*eps_z_a - 2*nu*rho_ii*P_cpp_MPa  #a) P_int = 0
    sigma_zL_b = E*eps_z_b + 2*nu*rho_i*P_int_MPa   #b) P_cpp = 0
    return (sigma_rL(r), sigma_tL(r), sigma_zL_a + sigma_zL_b)              #Superposition Principle

sigma_L = sigmaL_func(r, P_int_MPa, P_cpp_MPa, 1)
sigma_rL = sigma_L[0]  
sigma_tL = sigma_L[1]
sigma_zL = sigma_L[2]

if Mariotte_flag == 1:
    while True:
        try:
            Lame_flag = int(input("\nThe Mariotte solution for a thin cylinder has been visualized. Are you interested in visualizing the more general Lamé solution? (1: Yes, 0: No): "))
            if Lame_flag not in (0, 1):
                raise RuntimeError("Invalid input! Please enter either 0 or 1.")
            break  
        except ValueError:
            print("Please enter a valid integer.")
        except RuntimeError as e:
            print(e)

elif Mariotte_flag == 0:
    print("Visualizing general Lamé solution.")
    Lame_flag = 1

if Lame_flag == 1:
    # ======================================
    # Plotting the stress profiles: Lamé
    # ======================================
    plt.figure(figsize=(15,10))
    plt.axvline(x = R_int, color='black', linewidth='3', label='Vessel Inner Surface')
    plt.axvline(x = R_ext, color='black', linewidth='3', label='Vessel Outer Surface')
    plt.plot(r, sigma_rL, label='Radial (r) Stress Lamé')
    plt.plot(r, sigma_tL, label=r'Hoop ($\theta$) Stress Lamé')
    plt.axhline(y = sigma_zL, color='green', label='Axial (z) Stress Lamé')
    plt.axhline(y = 0, color='black', linewidth='1', label='y=0')
    plt.xlabel('Radius (m)')
    plt.ylabel('Stress (MPa)')
    plt.title('Stress Distribution in the cylinder wall - Lamé Solution')
    plt.legend()
    plt.grid()
    plt.show()

elif Lame_flag == 0:
    print("Skipping Lamé solution.")
    
# ======================================
# Thermal Shield Check
# ======================================    
while True:
    try:
        TS_flag = int(input("\nDo you want to consider the presence of a thermal shield between the barrel and the vessel? (1: Yes, 0: No): "))
        if TS_flag not in (0, 1):
            raise RuntimeError("Invalid input! Please enter either 0 or 1.")
        break  
    except ValueError:
        print("Please enter a valid integer.")
    except RuntimeError as e:
        print(e)

# =============================================================================================================================================================
# PURELY THERMAL PROBLEM - POWER IMPOSED - NO THERMAL SHIELD
# =============================================================================================================================================================
if TS_flag == 0:
    # ============================
    # Computed additional data without the thermal shield
    # ============================
    v = m_flr/(rho*np.pi*((D_vess_int**2)-(D_barr_ext**2))/4)     #m/s
    Phi_0V = Phi_0                                                #All gamma rays reach the vessel

    # ======================================
    # Radiation-induced heating in the vessel
    # ======================================
    Phi = lambda r: Phi_0V*np.exp(-mu_st*(r-R_int))    #1/(m²·s)
    I = lambda r: E_y_J*Phi(r)*B                       #W/(m²)
    q_0 = B*Phi_0V*E_y_J*mu_st                         #W/(m³)
    q_iii = lambda r: q_0*np.exp(-mu_st*(r-R_int))     #W/(m³)

    # ======================================
    # Plotting the volumetric heat source profiles 
    # ======================================
    while True:
        try:
            hs_flag = int(input("\nDo you want to visualize the volumetric heat source q0 inside the vessel's wall? (1: Yes, 0: No): "))
            if hs_flag not in (0, 1):
                raise RuntimeError("Invalid input! Please enter either 0 or 1.")
            break  
        except ValueError:
            print("Please enter a valid integer.")
        except RuntimeError as e:
            print(e)

    if hs_flag == 1:
        plt.figure(figsize=(10,10))
        plt.axvline(x = R_int, color='black', linewidth='3', label='Vessel Inner Surface')
        plt.axvline(x = R_ext, color='black', linewidth='3', label='Vessel Outer Surface')
        plt.plot(r, q_iii(r), 'g', label='Radial (r) Volumetric heat source profile')
        plt.plot(r[0], q_iii(r[0]), 'or', label='Vessel Inner Surface Value')
        plt.plot(r[-1], q_iii(r[-1]), 'or', label='Vessel-Insulation Interface Value')
        plt.axhline(y = 0, color='black', linewidth='1', label='y=0')
        plt.xlabel('Radius (m)')
        plt.ylabel(r'$q_0$ (W/m$^3$)')
        plt.title('Volumetric heat source profile across the vessel wall')
        plt.legend()
        plt.grid()
        plt.show()

    print("\nVolumetric heat source at the vessel inner surface: %.3f W/m³" %q_iii(r[0]))
    print("Volumetric heat source at the vessel-insulation interface: %.3f W/m³" %q_iii(r[-1]))

    # ======================================
    # Dimensionless numbers and heat transfer coefficients
    # ======================================
    Pr = (Cp*mu)/k                                                                              #Prandtl number
    Pr_cpp = (Cp_cpp*mu_cpp)/k_cpp                                                              #Prandtl number of the containment water  

                                       
    Re = (rho*v*(D_vess_int-D_barr_ext))/mu                                                     #Reynolds number
    Nu_1 = 0.023*(Re*0.8)*(Pr**0.4)                                                             #Dittus-Boelter equation for forced convection
    h_1 = (Nu_1*k)/(D_vess_int-D_barr_ext)                                                      #W/(m²·K)
    print("\nHeat transfer coefficient h1 = %.3f W/(m²·K)" %h_1)

    Gr = (rho_cpp**2)*9.81*beta_cpp*DeltaT*(L**3)/(mu_cpp**2)                                   #Grashof number (Uses the external diameter as characteristic length, might wanna use L though?)
    Nu_2 = 0.13*((Gr*Pr_cpp)**(1/3))                                                            #McAdams correlation for natural convection
    h_2 = (Nu_2*k_cpp)/L                                                                        #W/(m²·K)
    R_th_2_tot = (1/(2*np.pi*(R_ext + t_th_ins)*L)) * ((((R_ext + t_th_ins)/k_th_ins)*np.log((R_ext + t_th_ins)/R_ext)) + (1/h_2))                          #Thermal Resistance of the insulation layer + natural convection outside the vessel
    u_2 = 1/(2*np.pi*(R_ext + t_th_ins)*L*R_th_2_tot)                                           #W/(m²·K)   -   Overall heat transfer coefficient outside the vessel
    print("Heat transfer coefficient h2 = %.3f W/(m²·K)" %h_2)
    print("Overall heat transfer coefficient outside the vessel u2 = %.3f W/(m²·K)" %u_2)

    while True:
        try:
            q_0_flag = int(input("\nDo you want to account for the presence of the volumetric heat source q0 inside the vessel's wall? (1: Yes, 0: No): "))
            if q_0_flag not in (0, 1):
                raise RuntimeError("Invalid input! Please enter either 0 or 1.")
            break  
        except ValueError:
            print("Please enter a valid integer.")
        except RuntimeError as e:
            print(e)
    q_0 = q_0*q_0_flag

    # ======================================
    # Discretization Check
    # ======================================
    while True:
        try:
            Disc_flag = int(input("Do you want to use a discretization approach along z? (1: Yes, 0: No): "))
            if Disc_flag not in (0, 1):
                raise RuntimeError("Invalid input! Please enter either 0 or 1.")
            break  
        except ValueError:
            print("Please enter a valid integer.")
        except RuntimeError as e:
            print(e)

    # ======================================
    # 1D Approach: no discretization along z
    # ======================================
    if Disc_flag == 0:
        print("No discretization along z. Assuming constant temperature of the primary fluid T1.")
        while True:
            try:
                T1_flag = int(input("\nWhat temperature do you want to use as T1 to compute C1 and C2? (0: T_in, 1: T_in + 10%, 2: T_in + 20%, 3: T_avg, 4: T_out_avg): "))
                if T1_flag not in (0, 1, 2, 3, 4):
                    raise RuntimeError("Invalid input! Please enter one of the allowed values: 1, 2, 3, 4.")
                break  
            except ValueError:
                print("Please enter a valid integer.")
            except RuntimeError as e:
                print(e)
        while True:
            try:
                adiab_flag = int(input("Apply Adiabatic Outer Wall approximation? (1: Yes, 0: No): "))
                if adiab_flag not in (0, 1):
                    raise RuntimeError("Invalid input! Please enter either 0 or 1.")
                break  
            except ValueError:
                print("Please enter a valid integer.")
            except RuntimeError as e:
                print(e)

        if T1_flag == 0:                #All these temperatures are expressed in K. T_out_max and T_avg_log have been discarded in favor of margins on T_in, to account for transients due to the system's geometry
            T1 = T_in
        elif T1_flag == 1:
            T1 = T_in * 1.1
        elif T1_flag == 2:
            T1 = T_in * 1.2
        elif T1_flag == 3:
            T1 = ((T_in + T_out_avg)/2)
        elif T1_flag == 4:
            T1 = T_out_avg
        
        # ======================================
        # T profile constants for the vessel: general and under adiabatic outer wall approximation (dT/dx = 0 at r = R_ext)
        # ======================================
        if adiab_flag == 0:
            C1 = ((q_0/(k_st*mu_st**2))*(np.exp(-mu_st*t)-1)-(q_0/mu_st)*((1/h_1)+(np.exp(-mu_st*t)/u_2))-(T1-T_cpp))/(t+(k_st/h_1)+(k_st/u_2))
        elif adiab_flag == 1:
            C1 = -((q_0/(k_st*mu_st))*np.exp(-mu_st*t))
        C2 = T1 + (q_0/(h_1*mu_st)) + C1*(k_st/h_1) + (q_0/(k_st*mu_st**2))

        # ======================================
        # T profiles across the vessel wall, average Ts, maxima and their positions
        # ======================================
        T_vessel = lambda r: -((q_0/(k_st*mu_st**2))*np.exp(-mu_st*(r-R_int))) + C1*(r-R_int) + C2
        T_vessel_avg = (1/t)*integrate.quad(T_vessel, R_int, R_ext)[0]
        T_vessel_max = max(T_vessel(r))
        r_T_vessel_max = r[np.argmax(T_vessel(r))]
        #T_vessel_avg_2 = (q_0/(k_st*mu_st**2))*((np.exp(-mu_st*t)-1)/(mu_st*t))+ C1*(t/2) + C2                                          #Analytical Integration Result

        # ======================================
        # Thermal power fluxes (kW/m²) on the inner and outer vessel surface
        # ======================================
        DeltaT_1 = T1 - T_vessel(r[0])

        str1 = "\nT1 = T_in has been assumed: a logarithmic mean DeltaT could thus be useful to account for the T profile along z in an approximate way, even though the vessel wall temperature is not constant."
        str2 = "The heat flux computed with the regular DeltaT will still be displayed."
        str3 = "Do you want to adopt such an approach? (1: Yes, 0: No): "
        prompt = "\n".join([str1, str2, str3]) + " "
        if T1_flag == 0:
            while True:
                try:
                    LogDelta_flag = int(input(prompt))
                    if LogDelta_flag not in (0, 1):
                        raise RuntimeError("Invalid input! Please enter either 0 or 1.")
                    break  
                except ValueError:
                    print("Please enter a valid integer.")
                except RuntimeError as e:
                    print(e)
            if LogDelta_flag == 1:
                DeltaT_LM1 = ((T1-T_vessel(r[0]))-(T_out_avg-T_vessel(r[0])))/(np.log((T1-T_vessel(r[0]))/(T_out_avg-T_vessel(r[0]))))        #Log Mean Temperature Difference to account for T change along z, instead of just using T1-T_wall
                q_s1_log = h_1*DeltaT_LM1/1000                                                                                                                      #kW/m²
                print("\nThermal power flux on the inner vessel surface - Logarithmic Mean DeltaT Approach: %.3f kW/m²" %q_s1_log)
        q_s1 = h_1*DeltaT_1/1000                                                                                                          #kW/m²
        q_s2 = u_2*(T_vessel(r[-1])-T_cpp)/1000                                                                                           #kW/m²

        print("\nThermal power flux on the inner vessel surface: %.3f kW/m²" %q_s1)
        print("Thermal power flux on the outer vessel surface: %.3f kW/m²" %q_s2)

        # ======================================
        # Plotting the T profiles
        # ======================================
        while True:
            try:
                T_pl_flag = int(input("\nDo you want to visualize the T profile across the vessel's wall? (1: Yes, 0: No): "))
                if T_pl_flag not in (0, 1):
                    raise RuntimeError("Invalid input! Please enter either 0 or 1.")
                break  
            except ValueError:
                print("Please enter a valid integer.")
            except RuntimeError as e:
                print(e)
        
        if adiab_flag == 0:
            print("\nAverage Vessel Temperature (numerical integration): %.3f °C" %(T_vessel_avg - 273.15))
            #print("Average Vessel Temperature (analytical integration): %.3f °C" %T_vessel_avg_2)
            print("Maximum Vessel Temperature: %.3f °C at r = %.3f m" %(T_vessel_max - 273.15, r_T_vessel_max))
            print("Vessel Temperature at the inner surface: %-3f °C at r = %.3f m" %(T_vessel(r)[0] - 273.15, r[0]))
            print("Vessel Temperature at the outer surface: %-3f °C at r = %.3f m" %(T_vessel(r)[-1] - 273.15, r[-1]))
            if T_pl_flag == 1:
                plt.figure(figsize=(10,10))
                plt.axvline(x = R_int, color='black', linewidth='3', label='Vessel Inner Surface')
                plt.axvline(x = R_ext, color='black', linewidth='3', label='Vessel Outer Surface')
                plt.plot(r, T_vessel(r) - 273.15, label='Radial (r) T Profile')
                plt.plot(r_T_vessel_max, T_vessel_max - 273.15,'or',label='Max T')
                plt.axhline(y = T_vessel_avg - 273.15, color='green', label='Wall Average T')
                plt.xlabel('Radius (m)')
                plt.ylabel('T (°C)')
                plt.title('Wall Temperature Profile, Average and Maximum ')
                plt.legend()
                plt.grid()
                plt.show()
            
        elif adiab_flag == 1:
            print("\nAverage Vessel Temperature under Adiabatic Outer Wall approximation (numerical integration): %.3f °C" %(T_vessel_avg - 273.15))
            #print("Average Vessel Temperature under Adiabatic Outer Wall approximation (analytical integration): %.3f °C" %T_vessel_avg_2)
            print("Maximum Vessel Temperature under Adiabatic Outer Wall approximation: %.3f °C at r = %.3f m" %(T_vessel_max - 273.15, r_T_vessel_max))
            print("Vessel Temperature at the inner surface under Adiabatic Outer Wall approximation: %-3f °C at r = %.3f m" %(T_vessel(r)[0] - 273.15, r[0]))
            print("Vessel Temperature at the outer surface under Adiabatic Outer Wall approximation: %-3f °C at r = %.3f m" %(T_vessel(r)[-1] - 273.15, r[-1]))
            if T_pl_flag == 1:
                
                # ======================================
                # Under Adiabatic Outer Wall Approximation
                # ======================================
                plt.figure(figsize=(10,10))
                plt.axvline(x = R_int, color='black', linewidth='3', label='Vessel Inner Surface')
                plt.axvline(x = R_ext, color='black', linewidth='3', label='Vessel Outer Surface')
                plt.plot(r, T_vessel(r) - 273.15, label='Radial (r) T Profile')
                plt.plot(r_T_vessel_max, T_vessel_max - 273.15,'or', label='Max T')
                plt.axhline(y = T_vessel_avg - 273.15, color='green', label='Wall Average T')
                plt.xlabel('Radius (m)')
                plt.ylabel('T (°C)')
                plt.title('Wall Temperature Profile, Average and Maximum under AOW Approximation ')
                plt.legend()
                plt.grid()
                plt.show()
    
        # ======================================
        # Vessel's Wall Thermal stresses computation
        # ======================================
        f_V = lambda r: T_vessel(r)*r

        sigma_r_th_V = np.zeros(dr)
        sigma_t_th_V = np.zeros(dr)
        for i in range(len(r)):
            sigma_r_th_V[i] = (E*alpha_l/(1-nu))*(1/(r[i]**2)) * (( ((r[i]**2)-(R_int**2))/((R_ext**2)-(R_int**2)) ) * simpcomp(f_V, R_int, R_ext, dr) - simpcomp(f_V, R_int, r[i], dr))
            sigma_t_th_V[i] = (E*alpha_l/(1-nu))*(1/(r[i]**2)) * (( (((r[i]**2)+(R_int**2))/((R_ext**2)-(R_int**2)) ) * simpcomp(f_V, R_int, R_ext, dr)) + simpcomp(f_V, R_int, r[i], dr) - T_vessel(r[i])*(r[i]**2))
        sigma_t_th_V_SIMP = lambda r: (E*alpha_l/(1-nu))*(T_vessel_avg - T_vessel(r))                  #Simplified formula assuming average T
        sigma_z_th_V = sigma_r_th_V + sigma_t_th_V                                                     #Superposition principle under the hypothesis of long, hollow cylinder with load-free ends

        sigma_t_th_V_max = max(sigma_t_th_V)
        r_sigma_t_th_V_max = r[np.argmax(sigma_t_th_V)]
        print("\nMaximum Thermal Hoop Stress in the vessel: %.3f Mpa at r = %.3f m" %(sigma_t_th_V_max, r_sigma_t_th_V_max))
        #sigma_t_th_V_max_SIMP = max(sigma_t_th_V_SIMP(r))
        #r_sigma_t_th_V_max_SIMP = r[np.argmax(sigma_t_th_V_SIMP(r))]
        #print("Maximum Thermal Hoop Stress (Simplified formula): %.3f Mpa at r = %.3f m" %(sigma_t_th_V_max_SIMP, r_sigma_t_th_V_max_SIMP))

        # ======================================
        # Maximum Hoop Thermal Stress in the vessel via design curves
        # ======================================
        for i in range(len(indexes)):
            if mu_st > mu_values[i] and mu_st < mu_values[i+1]:
                mu_L = mu_values[i]
                mu_R = mu_values[i+1]
                #print("Current mu values: ", mu_values[i], mu_st, mu_values[i+1])
                current_L_key, current_R_key = keys_list[i], keys_list[i+1]
                x_points_L, x_points_R = mu_curves[current_L_key][2][:,0], mu_curves[current_R_key][2][:,0]
                y_points_L, y_points_R = mu_curves[current_L_key][2][:,1], mu_curves[current_R_key][2][:,1]

                p_L = np.polyfit(x_points_L, y_points_L, deg = 3)                   #len(y_points_L)-1
                p_R = np.polyfit(x_points_R, y_points_R, deg = 3)

                L_Interpolator = lambda x: np.polyval(p_L, x)
                R_Interpolator = lambda x: np.polyval(p_R, x)

                sigmaT_L = L_Interpolator(R_ext/R_int)                                                     #Interpolated sigmaT coefficient on the left ISO-mu 
                sigmaT_R = R_Interpolator(R_ext/R_int)                                                     #Interpolated sigmaT coefficient on the right ISO-mu 
                sigmaT_eq = lambda x: sigmaT_L + ((sigmaT_R-sigmaT_L)/(mu_R-mu_L))*(x - mu_L)
                sigmaT = sigmaT_eq(mu_st)                                                                  #Double-interpolated (linear) sigmaT coefficient
        
        sigma_t_th_max_DES = sigmaT*(alpha_l*E*q_0)/(k_st*(1-nu)*(mu_st**2))
        print("Maximum thermal hoop stress via design curves: %.3f MPa" %sigma_t_th_max_DES)

        # ======================================
        # Plotting the thermal stress profiles
        # ======================================
        while True:
            try:
                sigma_th_pl_flag = int(input("\nDo you want to visualize a plot of the thermal stress profiles in the vessel? (1: Yes, 0: No): "))
                if sigma_th_pl_flag not in (0, 1):
                    raise RuntimeError("Invalid input! Please enter either 0 or 1.")
                break  
            except ValueError:
                print("Please enter a valid integer.")
            except RuntimeError as e:
                print(e)

        if sigma_th_pl_flag == 1:
            plt.figure(figsize=(10,10))
            plt.axvline(x = R_int, color='black', linewidth='3', label='Vessel Inner Surface')
            plt.axvline(x = R_ext, color='black', linewidth='3', label='Vessel Outer Surface')
            plt.plot(r, sigma_r_th_V, linewidth='0.75', label='Radial (r) Thermal Stress Profile')
            plt.plot(r, sigma_t_th_V, linewidth='0.75', label='Hoop (θ) Thermal Stress Profile')
            #plt.plot(r, sigma_t_th_SIMP(r), label='Simplified Hoop (θ) Thermal Stress Profile')
            plt.plot(r, sigma_z_th_V, color='green', linewidth='0.5', label='Axial (z) Thermal Stress Profile')
            plt.axhline(y = 0, color='black', linewidth='1', label='y=0')
            plt.plot(r_sigma_t_th_V_max, sigma_t_th_V_max,'or', label='Max Hoop Stress')
            #plt.axvline(x=r_sigma_th_max_SIMP, color='cyan', linestyle='dashed', linewidth='0.5')
            #plt.axhline(y=sigma_th_max_SIMP, color='cyan', linestyle='dashed', linewidth='0.5')
            #plt.plot(r_sigma_th_max_SIMP, sigma_th_max_SIMP,'--oc', label='Simplified Max Hoop Stress')
            plt.xlabel('Radius (m)')
            plt.ylabel('Thermal Stress (MPa)')
            plt.title('Wall Thermal Stress Profiles and Maximum Hoop Stress')
            plt.legend()
            plt.grid()
            plt.show()

        # ======================================
        # Principal stresses sum and elastic regime verification in the vessel
        # ======================================
        sigma_r_totM = sigma_rM_cyl + sigma_r_th_V
        sigma_t_totM = sigma_tM_cyl + sigma_t_th_V
        sigma_z_totM = sigma_zM_cyl + sigma_z_th_V
        
        sigma_r_totL = sigma_rL + sigma_r_th_V
        sigma_t_totL = sigma_tL + sigma_t_th_V
        sigma_z_totL = sigma_zL + sigma_z_th_V
        
        # ============================ 
        # Vessel Comparison stress - Guest-Tresca Theory - Mariotte/Lamé + Thermal stresses
        # ============================
        sigma_cTR_M = np.max([abs(sigma_t_totM - sigma_r_totM), abs(sigma_z_totM - sigma_r_totM), abs(sigma_t_totM - sigma_z_totM)])
        sigma_cTR_L = np.max([abs(sigma_t_totL - sigma_r_totL), abs(sigma_z_totL - sigma_r_totL), abs(sigma_t_totL - sigma_z_totL)])
        print("\nGuest-Tresca Equivalent Stress in the vessel - Mariotte solution: %.3f Mpa" %sigma_cTR_M)
        print("Guest-Tresca Equivalent Stress in the vessel - Lamé solution: %.3f Mpa" %sigma_cTR_L)

        # ============================ 
        # Vessel Comparison stress - Von Mises Theory - Mariotte/Lamé + Thermal stresses
        # ============================
        sigma_cVM_M = max(np.sqrt(0.5*((sigma_r_totM - sigma_t_totM)**2 + (sigma_t_totM - sigma_z_totM)**2 + (sigma_z_totM - sigma_r_totM)**2)))
        sigma_cVM_L = max(np.sqrt(0.5*((sigma_r_totL - sigma_t_totL)**2 + (sigma_t_totL - sigma_z_totL)**2 + (sigma_z_totL - sigma_r_totL)**2))) #The max should be the worst case, in theory
        print("\nVon Mises Equivalent Stress in the vessel - Mariotte solution: %.3f Mpa" %sigma_cVM_M)
        print("Von Mises Equivalent Stress in the vessel - Lamé solution: %.3f Mpa" %sigma_cVM_L)

        # ======================================
        # Plotting the maximum thermal stress via the design curves
        # ======================================
        while True:
            try:
                des_pl_flag = int(input("\nDo you want to visualize a plot of the design curves and the maximum thermal stress in the vessel? (1: Yes, 0: No): "))
                if des_pl_flag not in (0, 1):
                    raise RuntimeError("Invalid input! Please enter either 0 or 1.")
                break  
            except ValueError:
                print("Please enter a valid integer.")
            except RuntimeError as e:
                print(e)

        if des_pl_flag == 1:
            plt.figure(figsize=(10,10))
            plt.plot(ba_ratio_plot, L_Interpolator(ba_ratio_plot), 'k', label=f'Iso-mu = {mu_L} 1/m')
            plt.plot(ba_ratio_plot, R_Interpolator(ba_ratio_plot), 'k', label=f'Iso-mu = {mu_R} 1/m')
            plt.plot(R_ext/R_int, sigmaT,'or', label=r'Current $\sigma$$_T$')
            plt.xlabel('b/a')
            plt.ylabel(r'$\sigma$$_T$')
            plt.title('Design curves')
            plt.legend()
            plt.grid()
            plt.show()
        
        # ============================ 
        # Yield Stress and Stress Intensity Data Interpolation
        # ============================
        T_des_vessel = T_vessel_avg                                                     #K  -   Check in the HARVEY/Thermomechanics Chapter how to choose the design T
        T_des_vessel_C = T_des_vessel - 273.15                                          #°C
        p_yield = np.polyfit(T_thr, sigma_y, deg = len(T_thr)-1)
        p_intensity = np.polyfit(T_thr, sigma_in, deg = len(T_thr)-1)
        
        Yield_Interpolator = lambda x: np.polyval(p_yield, x)                           #Yield Stress Interpolation Polynomial (n-1)
        Yield_CubicSpline = interpolate.CubicSpline(T_thr, sigma_y)                     #Yield Stress Cubic Spline Interpolation
        Yield_stress = Yield_CubicSpline(T_des_vessel_C)
        
        Intensity_Interpolator = lambda x: np.polyval(p_intensity, x)                   #Stress Intensity Interpolation Polynomial (n-1)
        Intensity_CubicSpline = interpolate.CubicSpline(T_thr, sigma_in)                #Stress Intenisty Cubic Spline Interpolation
        Stress_Intensity = Intensity_CubicSpline(T_des_vessel_C)
        print("\nFor a design vessel temperature of %.3f °C: " %T_des_vessel_C)
        print('Yield Stress: Sy'," = %.3f MPa" %Yield_stress)
        print('Stress Intensity: Sm'," = %.3f MPa" %Stress_Intensity)

        # ======================================
        # Without thermal shield
        # ======================================
        while True:
            try:
                Interp_pl_flag = int(input("\nDo you want to visualize a plot of the Yield Stress and Stress Intensity as given by ASME for the vessel? (1: Yes, 0: No): "))
                if Interp_pl_flag not in (0, 1):
                    raise RuntimeError("Invalid input! Please enter either 0 or 1.")
                break  
            except ValueError:
                print("Please enter a valid integer.")
            except RuntimeError as e:
                print(e)
        
        if max(T_thr) > T_des_vessel_C:
            Tplot = np.linspace(min(T_thr), max(T_thr), 1000)
        else:
            Tplot = np.linspace(min(T_thr), T_des_vessel_C, 1000)
        
        if Interp_pl_flag == 1:
            
            # ============================ 
            # Yield Stress and Stress Intensity Data Plots  -   Vessel
            # ============================
            plt.figure(figsize = (12,10))
            plt.subplot(1,2,1)
            plt.plot(T_thr, sigma_y, 'sk', label = 'Yield Stress Data')
            plt.plot(Tplot, Yield_Interpolator(Tplot), '--', color = 'orange', label = 'Yield Stress n-1 Interpolation')
            plt.plot(Tplot, Yield_CubicSpline(Tplot), 'green', label = 'Yield Stress Cubic Spline Interpolation')
            plt.plot(T_des_vessel_C, Yield_stress, '--or', label = r'Current Vessel Yield Stress $\sigma$$_y$')
            plt.xlabel("Temperature (°C)")
            plt.ylabel(r"Yield Stress $\sigma$$_y$")
            plt.title("Yield Stress Data and Interpolation VS Temperature", fontsize = 10)
            plt.legend()
            plt.grid()
            plt.tight_layout()
            
            plt.subplot(1,2,2)
            plt.plot(T_thr, sigma_in, 'sk', label = 'Stress Intensity Data')
            plt.plot(Tplot, Intensity_Interpolator(Tplot), '--', color = 'orange', label = 'Stress Intensity n-1 Interpolation')
            plt.plot(Tplot, Intensity_CubicSpline(Tplot), 'green', label = 'Stress Intensity Cubic Spline Interpolation')
            plt.plot(T_des_vessel_C, Stress_Intensity, '--or', label = r'Current Vessel Stress Intensity $\sigma$$_m$')
            plt.xlabel("Temperature (°C)")
            plt.ylabel(r"Stress Intensity $\sigma$$_m$")
            plt.title("Stress Intensity Data and Interpolation VS Temperature", fontsize = 10)
            plt.legend()
            plt.grid()
            plt.tight_layout()
            plt.show()
    
        # ============================ 
        # Sizing of a thick cylinder under external pressure
        # ============================
        if Mar_criterion > 5:
            while True:
                try:
                    ThinTubes_flag = int(input("\nThe vessel's wall can be considered thin. Are you interested in the thin tube limits for Elastic Instability and Plastic Collapse? (1: Yes, 0: No): "))
                    if ThinTubes_flag not in (0, 1):
                        raise RuntimeError("Invalid input! Please enter either 0 or 1.")
                    break  
                except ValueError:
                    print("Please enter a valid integer.")
                except RuntimeError as e:
                    print(e)

            if ThinTubes_flag == 1:
                p_E_fun = lambda Dt: 2 * (E/(1-(nu**2))) * (1/(Dt**3))              #Elastic Instability Limit for Thin Tubes
                p_0_fun = lambda Dt: 2 * Yield_stress * 1/Dt                        #Plastic Collapse Limit for Thin Tubes

            elif ThinTubes_flag == 0:
                print("Skipping thin tube limits.")
        else:
            print("\nThe cylinder can't be considered thin. Skipping thin tube limits.")
            ThinTubes_flag = 0

        # ============================ 
        # Corradi Design Procedure
        # ============================
        if ThinTubes_flag == 1:
            while True:
                try:
                    Corradi_flag = int(input("\nThe thin tube limits were adopted. Are you interested in the more general Corradi Design Procedure? (1: Yes, 0: No): "))
                    if Corradi_flag not in (0, 1):
                        raise RuntimeError("Invalid input! Please enter either 0 or 1.")
                    break  
                except ValueError:
                    print("Please enter a valid integer.")
                except RuntimeError as e:
                    print(e)
            
        elif ThinTubes_flag == 0:
            print("Adopting Corradi Design Procedure.")
            Corradi_flag = 1

        q_E_fun = lambda Dt: 2 * (E/(1-(nu**2))) * (1/(Dt*((Dt-1)**2)))     #Elastic Instability Limit for Thick Tubes
        q_0_fun = lambda Dt: 2 * Yield_stress * 1/Dt * (1+(1/(2*Dt)))       #Plastic Collapse Limit for Thick Tubes
        Dt_Crit_Ratio = np.sqrt(E/(Yield_stress*(1-(nu**2))))
        Current_Slenderness = (D_vess_int+2*t)/t
        Dt_ratio_plot = np.linspace(2,50,1000)

        if Corradi_flag == 1:
            # ============================ 
            # Corradi Design Procedure
            # ============================
            while True:
                try:
                    s = float(input("Please enter a safety factor between 1.5 and 2 for the Corradi design procedure: "))
                    if s < 1.5 or s > 2:
                        raise RuntimeError("Invalid input! Please enter a safety factor between 1.5 and 2.")
                    break  
                except ValueError:
                    print("Please enter a valid float.")
                except RuntimeError as e:
                    print(e)
            
            def Corradi(Slenderness):
                if ThinTubes_flag == 1:
                    print("Adopting Corradi Design Procedure.")

                if isinstance(Slenderness, np.ndarray):
                    mu = np.zeros(len(Slenderness))
                    Z = lambda Dt: (np.sqrt(3)/4) * (2*Dt + 1) * W                  #Accounts for ovality
                    q_U = lambda Dt: q_0_fun(Dt)/np.sqrt(1+(Z(Dt)**2))
                    q_L = lambda Dt: (1/2) * (q_0_fun(Dt) + q_E_fun(Dt)*(1 + Z(Dt)) - np.sqrt(((q_0_fun(Dt) + q_E_fun(Dt)*(1 + Z(Dt)))**2)-(4 * q_0_fun(Dt) * q_E_fun(Dt))))
                    
                    for i in range(len(mu)):
                        if q_0_fun(Slenderness[i])/q_E_fun(Slenderness[i]) < 0.04:
                            mu[i] = 1
                        elif 0.04 <= q_0_fun(Slenderness[i])/q_E_fun(Slenderness[i]) <= 0.7:
                            mu[i] = (0.35 * np.log(q_E_fun(Slenderness[i])/q_0_fun(Slenderness[i]))) - 0.125
                        elif q_0_fun(Slenderness[i])/q_E_fun(Slenderness[i]) > 0.7:
                            mu[i] = 0
                        
                    q_C = mu*q_U(Slenderness) + (1-mu)*q_L(Slenderness)
                    q_a = q_C/s
                else:
                    raise TypeError("The 1st input must be a numpy array.")
                if len(q_C) == 1:
                    q_C = q_C.item()
                if len(q_a) == 1:
                    q_a = q_a.item()
                if len(mu) == 1:
                    mu = mu.item()
                return (q_C, q_a, s, mu)
            
            # ============================ 
            # Corradi Design Procedure Results
            # ============================
            Corradi_vessel = Corradi(np.array([Current_Slenderness]))
            print("\nAccording to the Corradi Design Procedure:")
            print("The theoretical limit for collapse pressure, accounting for ovality, is: q_c = %.3f MPa = %.3f bar" %(Corradi_vessel[0], 10*Corradi_vessel[0]))
            print("A safety factor s = %.3f was assumed. \nThe allowable external pressure is thus: q_a = %.3f MPa = %.3f bar" %(Corradi_vessel[2], Corradi_vessel[1], 10*Corradi_vessel[1]))
            
            if (P_cpp < 10*Corradi_vessel[1]):
                print("The given external pressure of %.3f bar is lower than the allowable pressure of %.3f bar: SUCCESS!" %(P_cpp, 10*Corradi_vessel[1]))
            else:
                print("The given external pressure of %.3f bar is higher than the allowable pressure of %.3f bar: a change in thickness is required!" %(P_cpp, 10*Corradi_vessel[1]))
        
        elif Corradi_flag == 0:
            print("Skipping Corradi Design Procedure.")
        
        # ============================ 
        # Elastic instability and plastic collapse curves
        # ============================
        if ThinTubes_flag == 1 and Corradi_flag == 0:
            while True:
                try:
                    Collapse_pl_flag = int(input("\nDo you want to visualize the buckling and plastic collapse curves for thin and thick tubes? (1: Yes, 0: No): "))
                    if Collapse_pl_flag not in (0, 1):
                        raise RuntimeError("Invalid input! Please enter either 0 or 1.")
                    break  
                except ValueError:
                    print("Please enter a valid integer.")
                except RuntimeError as e:
                    print(e)
            
            if Collapse_pl_flag == 1:
                
                # ============================ 
                # Plastic collapse and buckling Plots
                # ============================
                plt.figure(figsize = (8, 8))
                plt.semilogy(Dt_ratio_plot, p_E_fun(Dt_ratio_plot), 'blue', label='p$_E$')
                plt.semilogy(Dt_ratio_plot, q_E_fun(Dt_ratio_plot), '--b', label='q$_E$')
                plt.semilogy(Dt_ratio_plot, p_0_fun(Dt_ratio_plot), 'red', label='p$_0$')
                plt.semilogy(Dt_ratio_plot, q_0_fun(Dt_ratio_plot), '--r', label='q$_0$')
                plt.axvline(x = Dt_Crit_Ratio, color = 'black', linewidth = '3', label = 'Critical Slenderness')
                plt.axvline(x = Current_Slenderness, color = 'green', linewidth = '3', label = 'Current Vessel Slenderness')
                plt.xlabel("Geometrical Slenderness D/t")
                plt.ylabel("Theoretical Limit Values (MPa)")
                plt.title("Plastic Collapse and Buckling Curves")
                plt.legend()
                plt.grid()
                plt.show()

        elif ThinTubes_flag == 1 and Corradi_flag == 1:
            while True:
                try:
                    Collapse_pl_flag = int(input("\nDo you want to visualize the buckling and plastic collapse curves for thin and thick tubes and the Corradi curve? (1: Yes, 0: No): "))
                    if Collapse_pl_flag not in (0, 1):
                        raise RuntimeError("Invalid input! Please enter either 0 or 1.")
                    break  
                except ValueError:
                    print("Please enter a valid integer.")
                except RuntimeError as e:
                    print(e)
            
            if Collapse_pl_flag == 1:
                
                # ============================ 
                # Plastic collapse and buckling Plots
                # ============================
                plt.figure(figsize = (8, 8))
                plt.subplot(1,2,1)
                plt.semilogy(Dt_ratio_plot, p_E_fun(Dt_ratio_plot), 'blue', label='p$_E$')
                plt.semilogy(Dt_ratio_plot, q_E_fun(Dt_ratio_plot), '--b', label='q$_E$')
                plt.semilogy(Dt_ratio_plot, p_0_fun(Dt_ratio_plot), 'red', label='p$_0$')
                plt.semilogy(Dt_ratio_plot, q_0_fun(Dt_ratio_plot), '--r', label='q$_0$')
                plt.semilogy(Dt_ratio_plot, Corradi(Dt_ratio_plot)[0], 'orange', label='Corradi q$_c$')
                plt.axvline(x = Dt_Crit_Ratio, color = 'black', linewidth = '3', label = 'Critical Slenderness')
                plt.axvline(x = Current_Slenderness, color = 'green', linewidth = '3', label = 'Current Vessel Slenderness')
                plt.xlabel("Geometrical Slenderness D/t")
                plt.ylabel("Theoretical Limit Values (MPa)")
                plt.title("Plastic Collapse and Buckling Curves")
                plt.legend()
                plt.grid()
                plt.tight_layout()

                plt.subplot(1,2,2)
                plt.plot(Dt_ratio_plot, Corradi(Dt_ratio_plot)[3], 'k', label=r'Corradi $\mu$')
                plt.xlabel("Geometrical Slenderness D/t")
                plt.ylabel(r"Corradi $\mu$")
                plt.title(r"$\mu$ coefficient - Corradi Procedure")
                plt.legend()
                plt.grid()
                plt.tight_layout()
                plt.show()

    # ======================================
    # Discretization along z
    # ======================================
    elif Disc_flag == 1:
        
        # ======================================
        # T discretization along z
        # ======================================
        dz = 100
        T_z = np.linspace(T_in, T_out_avg, dz)
        while True:
            try:
                adiab_flag = int(input("\nApply Adiabatic Outer Wall approximation? (1: Yes, 0: No): "))
                if adiab_flag not in (0, 1):
                    raise RuntimeError("Invalid input! Please enter either 0 or 1.")
                break  
            except ValueError:
                print("Please enter a valid integer.")
            except RuntimeError as e:
                print(e)

        if adiab_flag == 0:
            C1 = ((q_0/(k_st*mu_st**2))*(np.exp(-mu_st*t)-1)-(q_0/mu_st)*((1/h_1)+(np.exp(-mu_st*t)/u_2))-(T_z - T_cpp))/(t+(k_st/h_1)+(k_st/u_2))      # Make C1 a 1D array aligned with T_z (avoid wrapping in another dimension)
        elif adiab_flag == 1:
            C1 = np.full_like(T_z, -((q_0/(k_st*mu_st)) * np.exp(-mu_st*t)))                                                                                       # Constant C1 for all z points -> replicate to match T_z shape
        C2 = T_z + (q_0/(h_1*mu_st)) + C1 * (k_st/h_1) + (q_0/(k_st*mu_st**2))                                                                                     # C2 should also be a 1D array matching T_z
        
        # ======================================
        # T profiles across the vessel wall, average Ts, maxima and their positions
        # ======================================
        def T_vessel_func_all(r, C1, C2):
            T_vessel_r = np.zeros((dz, dr))
            T_vessel_avg_arr = np.zeros(dz)
            T_vessel_max_arr = np.zeros(dz)
            r_T_vessel_max_arr = np.zeros(dz)
            sigma_r_th = np.zeros((dz, dr))
            sigma_t_th = np.zeros((dz, dr))
            sigma_t_th_SIMP = np.zeros((dz, dr))

            for i in range(dz):
                # ======================================
                # T Profiles computation
                # ======================================
                T_vessel_r[i, :] = -((q_0/(k_st*mu_st**2)) * np.exp(-mu_st * (r - R_int))) + C1[i] * (r - R_int) + C2[i]                               # vectorized radial temperature for this z-index               
                T_vessel_r_lamb = lambda rr: -((q_0/(k_st*mu_st**2)) * np.exp(-mu_st * (rr - R_int))) + C1[i] * (rr - R_int) + C2[i]                   # use a lambda that accepts a scalar rr (avoid shadowing array `r`)
                T_vessel_avg_arr[i] = (1 / t) * integrate.quad(T_vessel_r_lamb, R_int, R_ext)[0]                                                       # integrate the scalar function over radius (returns scalar)
                T_vessel_max_arr[i] = np.max(T_vessel_r[i, :])
                r_T_vessel_max_arr[i] = r[np.argmax(T_vessel_r[i, :])]
                print("progress: %.3i/%.3i" %(i, dz))
                # ======================================
                # Thermal stresses computation
                # ======================================
                ff = lambda rr: (-((q_0/(k_st*mu_st**2)) * np.exp(-mu_st * (rr - R_int))) + C1[i] * (rr - R_int) + C2[i])*rr
                for j in range(dr):
                    sigma_r_th[i, j] = (E*alpha_l/(1-nu))*(1/(r[j]**2)) * (( ((r[j]**2)-(R_int**2))/((R_ext**2)-(R_int**2)) ) * simpcomp(ff, R_int, R_ext, dr) - simpcomp(ff, R_int, r[j], dr))
                    sigma_t_th[i, j] = (E*alpha_l/(1-nu))*(1/(r[j]**2)) * (( (((r[j]**2)+(R_int**2))/((R_ext**2)-(R_int**2)) ) * simpcomp(ff, R_int, R_ext, dr)) + simpcomp(ff, R_int, r[j], dr) - T_vessel_r_lamb(r[j])*(r[j]**2))
                    sigma_t_th_SIMP[i, j] = (E*alpha_l/(1-nu))*(T_vessel_avg_arr[i] - T_vessel_r_lamb(r[j]))   
            sigma_z_th = sigma_r_th + sigma_t_th                                          

            return (T_vessel_r, T_vessel_avg_arr, T_vessel_max_arr, r_T_vessel_max_arr, sigma_r_th, sigma_t_th, sigma_t_th_SIMP, sigma_z_th)
        
        Output = T_vessel_func_all(r, C1, C2)
        T_vessel_Mat = Output[0]
        T_vessel_avg_arr = Output[1]
        T_vessel_max_arr = Output[2]
        r_T_vessel_max_arr = Output[3]
        sigma_r_th = Output[4]
        sigma_t_th = Output[5]
        sigma_t_th_SIMP = Output[6]
        sigma_z_th = Output[7]
        
        # ======================================
        # Thermal power fluxes (kW/m²) on the inner and outer vessel surface
        # ======================================
        DeltaT_1 = np.zeros(len(T_z))
        q_s1 = np.zeros(len(T_z))
        q_s2 = np.zeros(len(T_z))
        for i in range(len(T_z)):
            DeltaT_1[i] = T_z[i] - T_vessel_Mat[i, 0]                               #Between the vessel's inner surface and the primary fluid
            q_s1[i] = h_1*DeltaT_1[i]/1000                                          #kW/m²
            q_s2[i] = u_2*(T_vessel_Mat[i, -1]-T_cpp)/1000               #kW/m²
        
        print("\nThermal power flux on the inner vessel surface: \nMin: %.3f kW/m² \nMax: %.3f kW/m²" %(np.min(q_s1),np.max(q_s1)))
        print("\nThermal power flux on the outer vessel surface: \nMin: %.3f kW/m² \nMax: %.3f kW/m²" %(np.min(q_s2),np.max(q_s2)))

        # ======================================
        # Plotting the wall T profiles
        # ======================================
        if adiab_flag == 0:
            
            # ======================================
            # Wall T(T_z, r) map
            # ======================================
            R_mesh, T_z_mesh = np.meshgrid(r, T_z - 273.15)                                                      #Shapes (Nz, Nr)
            plt.figure(figsize=(15,10))
            plt.subplot(1,2,1)
            pcm = plt.pcolormesh(R_mesh, T_z_mesh, T_vessel_Mat - 273.15, shading='auto', cmap='hot')   #Or 'hot','plasma','viridis'
            plt.colorbar(pcm, label='T (°C)')
            plt.xlabel('Radius (m)')
            plt.ylabel('T$_z$ (°C)')
            plt.title('Wall Temperature Map (r vs T$_z$)')
            plt.tight_layout()
            
            # ======================================
            # T_avg and T_max profiles as T_z grows
            # ======================================
            plt.subplot(1,2,2)
            plt.plot(T_z - 273.15, T_vessel_max_arr - 273.15, 'r', label='Max T Axial (z) Profile')              #The r position of T_max is always the same in this approach!
            plt.plot(T_z - 273.15, T_vessel_avg_arr - 273.15, 'k', label='Average T Axial (z) Profile')
            plt.xlabel('T$_z$ (°C)')
            plt.ylabel('T (°C)')
            plt.title('Maximum and Average Wall Temperature Profiles as T$_z$ grows')
            plt.legend()
            plt.grid()
            plt.show()
            
        elif adiab_flag == 1:
            
            # ======================================
            # Wall T(T_z, r) map
            # ======================================
            R_mesh, T_z_mesh = np.meshgrid(r, T_z - 273.15)
            plt.figure(figsize=(15,10))
            plt.subplot(1,2,1)
            pcm = plt.pcolormesh(R_mesh, T_z_mesh, T_vessel_Mat - 273.15, shading='auto', cmap='hot')
            plt.colorbar(pcm, label='T (°C)')
            plt.xlabel('Radius (m)')
            plt.ylabel('T$_z$ (°C)')
            plt.title('Wall Temperature Map under AOW Approximation (r vs T$_z$)')
            plt.tight_layout()
            
            # ======================================
            # T_avg and T_max profiles as T_z grows
            # ======================================
            plt.subplot(1,2,2)
            plt.plot(T_z - 273.15, T_vessel_max_arr - 273.15, 'r', label='Max T Axial (z) Profile')
            plt.plot(T_z - 273.15, T_vessel_avg_arr - 273.15, 'k', label='Average T Axial (z) Profile')
            plt.xlabel('T$_z$ (°C)')
            plt.ylabel('T (°C)')
            plt.title('Maximum and Average Wall Temperature Profiles as T$_z$ grows under AOW Approximation')
            plt.legend()
            plt.grid()
            plt.show()
        
        # ======================================
        # Plotting the thermal stress profiles
        # ======================================
        R_mesh, T_z_mesh = np.meshgrid(r, T_z - 273.15)   # shapes (Nz, Nr)
        plt.figure(figsize=(20,20))
        plt.subplot(1,4,1)
        pcm = plt.pcolormesh(R_mesh, T_z_mesh, sigma_r_th, shading='auto', cmap='viridis')
        plt.colorbar(pcm, label=r'$\sigma$ (MPa)')
        plt.xlabel('Radius (m)')
        plt.ylabel('T (°C)')
        plt.title('Radial Stress Map (r vs T$_z$)')
        plt.tight_layout()

        plt.subplot(1,4,2)
        pcm = plt.pcolormesh(R_mesh, T_z_mesh, sigma_t_th, shading='auto', cmap='viridis')
        plt.colorbar(pcm, label=r'$\sigma$ (MPa)')
        plt.xlabel('Radius (m)')
        plt.ylabel('T (°C)')
        plt.title('Hoop Stress Map (r vs T$_z$)')
        plt.tight_layout()

        plt.subplot(1,4,3)
        pcm = plt.pcolormesh(R_mesh, T_z_mesh, sigma_t_th_SIMP, shading='auto', cmap='viridis')
        plt.colorbar(pcm, label=r'$\sigma$ (MPa)')
        plt.xlabel('Radius (m)')
        plt.ylabel('T (°C)')
        plt.title('Simplified Hoop Stress Map (r vs T$_z$)')
        plt.tight_layout()

        plt.subplot(1,4,4)
        pcm = plt.pcolormesh(R_mesh, T_z_mesh, sigma_z_th, shading='auto', cmap='viridis')
        plt.colorbar(pcm, label=r'$\sigma$ (MPa)')
        plt.xlabel('Radius (m)')
        plt.ylabel('T (°C)')
        plt.title('Axial Stress Map (r vs T$_z$)')
        plt.tight_layout()
        plt.show()

# =============================================================================================================================================================
# PURELY THERMAL PROBLEM - POWER IMPOSED - THERMAL SHIELD
# =============================================================================================================================================================
elif TS_flag == 1:

    t_shield_user = 0.001           #Initial guess for the thermal shield thickness

    while True:
        try:
            User_D_flag = float(input("\nWhat position of the thermal shield do you want to consider? (2: Arbitrary, 1: Middle, 0: Equal areas): "))
            if User_D_flag not in (0, 1, 2):
                raise RuntimeError("Invalid input! Please enter either 0, 1 or 2.")
            break  
        except ValueError:
            print("Please enter a valid integer.")
        except RuntimeError as e:
            print(e)

    if User_D_flag == 2:            #Allows the user to assume the default, middle position for the thermal shield, position it himself or choose the position granting equal areas
        while True:
            try:
                D_shield_int = float(input("\nPlease enter the initial thermal shield inner diameter (m) to choose its position: "))
                if (D_shield_int < D_barr_ext) or (D_shield_int/2 + t_shield_user) > D_vess_int/2:
                    raise RuntimeError("The thermal shield is either starting inside the barrel or clipping inside the vessel.")
                break  
            except ValueError:
                print("Please enter a valid float.")
            except RuntimeError as e:
                print(e)
        R_shield_int = D_shield_int/2
        
    elif User_D_flag == 1:
        print("Assuming middle thermal shield position.")
        R_shield_int = D_barr_ext/2 + (D_vess_int - D_barr_ext)/4 - t_shield_user/2
         
    elif User_D_flag == 0:
        A_eq = 1
        B_eq = t_shield_user
        C_eq = (t_shield_user**2)/2 - (R_int**2)/2 - (R_barr_ext**2)/2
        Delta_eq = B_eq**2 - 4*A_eq*C_eq
        R_shield_int = (-B_eq + np.sqrt(Delta_eq))/(2*A_eq)
        D_shield_int = 2*R_shield_int

    print("No discretization along z. Assuming constant temperature of the primary fluid T1.")
    while True:
        try:
            T1_flag = int(input("\nWhat temperature do you want to use as T1 to compute C1 and C2? (0: T_in, 1: T_in + 10%, 2: T_in + 20%, 3: T_avg, 4: T_out_avg): "))
            if T1_flag not in (0, 1, 2, 3, 4):
                raise RuntimeError("Invalid input! Please enter one of the allowed values: 1, 2, 3, 4.")
            break  
        except ValueError:
            print("Please enter a valid integer.")
        except RuntimeError as e:
            print(e)
    while True:
        try:
            adiab_flag = int(input("Apply Adiabatic Outer Wall approximation? (1: Yes, 0: No): "))
            if adiab_flag not in (0, 1):
                raise RuntimeError("Invalid input! Please enter either 0 or 1.")
            break  
        except ValueError:
            print("Please enter a valid integer.")
        except RuntimeError as e:
            print(e)

    # =============================================================================================================================================================
    # Thermal Shield Thickness Iterative Computation
    # =============================================================================================================================================================
    final_flag = 0
    counter = 0
    counter_vessel = 0
    N_max = 10000
    eps = 1e-7                              #np.finfo(float).eps (excessive)

    t_shield = t_shield_user - 0.001
    t_shield_max = 0.1                      #arbitrary and perhaps excessive
    t_vessel_max = 0.3
    
    p_yield = np.polyfit(T_thr, sigma_y, deg = len(T_thr)-1)
    p_intensity = np.polyfit(T_thr, sigma_in, deg = len(T_thr)-1)
    
    Yield_Interpolator = lambda x: np.polyval(p_yield, x)                           #Yield Stress Interpolation Polynomial (n-1)
    Yield_CubicSpline = interpolate.CubicSpline(T_thr, sigma_y)                     #Yield Stress Cubic Spline Interpolation
    Intensity_Interpolator = lambda x: np.polyval(p_intensity, x)                   #Stress Intensity Interpolation Polynomial (n-1)
    Intensity_CubicSpline = interpolate.CubicSpline(T_thr, sigma_in)                #Stress Intenisty Cubic Spline Interpolation
    Dt_ratio_plot = np.linspace(2,50,1000)
    
    while True:
        try:
            s = float(input("Please enter a safety factor between 1.5 and 2 for the Corradi design procedure: "))
            if s < 1.5 or s > 2:
                raise RuntimeError("Invalid input! Please enter a safety factor between 1.5 and 2.")
            break  
        except ValueError:
            print("Please enter a valid float.")
        except RuntimeError as e:
            print(e)

    while final_flag == 0:
        t_shield += 0.001
        counter += 1
        print("Iteration no. %d" %counter)
        if counter > N_max:
            print("Exceeded maximum number of iterations: %d. Exiting the loop." %N_max)
            break
        if t > t_vessel_max:
            print("Vessel thickness exceeds feasibility margin. Exiting the loop.")
            break
        if User_D_flag == 2 or User_D_flag == 0:        #If the thermal shield is not in the middle, geometrical constraints are present: the thermal shield must not bump into the vessel
            if t_shield > t_shield_max or (D_shield_int/2 + t_shield) > D_vess_int/2:
                print("Ran into excessive thermal shield thickness or bumped into the vessel. Adding 1cm to the vessel thickness instead. Restarting...")
                t += 0.01
                t_shield = t_shield_user - 0.001
                counter_vessel += 1
                continue
        elif User_D_flag == 1:      #If the thermal shield is in the middle, only its thickness must be checked: no geometrical constraints
            if t_shield > t_shield_max:
                print("Ran into excessive thermal shield thickness. Adding 1cm to the vessel thickness instead. Restarting...")
                t += 0.01
                t_shield = t_shield_user - 0.001
                counter_vessel += 1
                continue

        if User_D_flag == 2:
            R_shield_int = D_shield_int/2
            
        elif User_D_flag == 1:
            R_shield_int = D_barr_ext/2 + (D_vess_int - D_barr_ext)/4 - t_shield/2
            D_shield_int = 2*R_shield_int
            
        elif User_D_flag == 0:
            A_eq = 1
            B_eq = t_shield
            C_eq = (t_shield**2)/2 - (R_int**2)/2 - (R_barr_ext**2)/2
            Delta_eq = B_eq**2 - 4*A_eq*C_eq
            R_shield_int = (-B_eq + np.sqrt(Delta_eq))/(2*A_eq)
            D_shield_int = 2*R_shield_int
            
        R_shield_ext = R_shield_int + t_shield
        D_shield_ext = 2*R_shield_ext
        
        r_S = np.linspace(R_shield_int, R_shield_ext, dr)
        Phi_0S = Phi_0                                                #All gamma rays reach the shield, not the vessel

        # ======================================
        # Dimensionless numbers and heat transfer coefficients
        # ======================================
        A_int_S = np.pi*((R_shield_int**2) - (R_barr_ext**2))                                       #Inner area crossed by the primary fluid
        A_ext_S = np.pi*((R_int**2) - (R_shield_ext**2))                                            #Outer area crossed by the primary fluid
        v_int = v_flr/A_int_S                                                                       #Inner coolant velocity
        v_ext = v_flr/A_ext_S
        
        Pr = (Cp*mu)/k                                                                              #Prandtl number
        Pr_cpp = (Cp_cpp*mu_cpp)/k_cpp                                                              #Prandtl number of the containment water
        
        Re_int = (rho*v_int*(D_shield_int - D_barr_ext))/mu                                         #Inner hydraulic diameter                                                     
        Nu_1_int = 0.023*(Re_int*0.8)*(Pr**0.4)                                                             
        h_1_int = (Nu_1_int*k)/(D_shield_int - D_barr_ext)
        
        Re_ext = (rho*v_ext*(D_vess_int - D_shield_ext))/mu                                         #Outer hydraulic diameter                                                     
        Nu_1_ext = 0.023*(Re_ext*0.8)*(Pr**0.4)                                                             
        h_1_ext = (Nu_1_ext*k)/(D_vess_int - D_shield_ext)
                                                                                 
        Gr = (rho_cpp**2)*9.81*beta_cpp*DeltaT*(L**3)/(mu_cpp**2)                                   #Grashof number (Uses the external diameter as characteristic length, might wanna use L though?)
        Nu_2 = 0.13*((Gr*Pr_cpp)**(1/3))                                                            #McAdams correlation for natural convection
        h_2 = (Nu_2*k_cpp)/L                                                                        #W/(m²·K)
        R_th_2_tot = (1/(2*np.pi*(R_ext + t_th_ins)*L)) * ((((R_ext + t_th_ins)/k_th_ins)*np.log((R_ext + t_th_ins)/R_ext)) + (1/h_2))                          #Thermal Resistance of the insulation layer + natural convection outside the vessel
        u_2 = 1/(2*np.pi*(R_ext + t_th_ins)*L*R_th_2_tot)                                           #W/(m²·K)   -   Overall heat transfer coefficient outside the vessel

        if T1_flag == 0:                #All these temperatures are expressed in K. T_out_max and T_avg_log have been discarded in favor of margins on T_in, to account for transients due to the system's geometry
            T1 = T_in
        elif T1_flag == 1:
            T1 = T_in * 1.1
        elif T1_flag == 2:
            T1 = T_in * 1.2
        elif T1_flag == 3:
            T1 = ((T_in + T_out_avg)/2)
        elif T1_flag == 4:
            T1 = T_out_avg

        R_ext = R_int + t
        r = np.linspace(R_int, R_ext, dr)

        # ======================================
        # Radiation-induced heating in the thermal shield
        # ======================================
        Phi_S = lambda r: Phi_0S*np.exp(-mu_st*(r-R_shield_int))       #1/(m²·s)
        I_S = lambda r: E_y_J*Phi_S(r)*B                               #W/(m²)
        q_0S = B*Phi_0S*E_y_J*mu_st                                    #W/(m³)
        q_iiiS = lambda r: q_0S*np.exp(-mu_st*(r-R_shield_int))        #W/(m³)

        # ======================================
        # Radiation-induced heating in the vessel
        # ======================================
        Phi = lambda r: (Phi_S(r_S)[-1])*np.exp(-mu_st*(r-R_int))      #1/(m²·s)
        I = lambda r: E_y_J*Phi(r)*B                                   #W/(m²)
        q_0 = B*(Phi_S(r_S)[-1])*E_y_J*mu_st                           #W/(m³)
        q_iii = lambda r: q_0*np.exp(-mu_st*(r-R_int))                 #W/(m³) 
        
        # ======================================
        # T profile constants for the vessel: general and under adiabatic outer wall approximation (dT/dx = 0 at r = R_ext)
        # ======================================
        if User_D_flag == 2 or User_D_flag == 1:
            h_1 = min(h_1_int, h_1_ext)                 #Conservative: minimum h means highest thermal stresses
        elif User_D_flag == 0:
            if h_1_int - h_1_ext <= eps:
                h_1 = h_1_int                           #Below the tolerance, they can be considered equal
            
        if adiab_flag == 0:
            C1 = ((q_0/(k_st*mu_st**2))*(np.exp(-mu_st*t)-1)-(q_0/mu_st)*((1/h_1)+(np.exp(-mu_st*t)/u_2))-(T1-T_cpp))/(t+(k_st/h_1)+(k_st/u_2))
        elif adiab_flag == 1:
            C1 = -((q_0/(k_st*mu_st))*np.exp(-mu_st*t))
        C2 = T1 + (q_0/(h_1*mu_st)) + C1*(k_st/h_1) + (q_0/(k_st*mu_st**2))

        # ======================================
        # T profile constants for the thermal shield
        # ======================================
        C1_S = ((q_0S/(k_st*mu_st**2))*(np.exp(-mu_st*t_shield)-1)-(q_0S/mu_st)*((1/h_1)+(np.exp(-mu_st*t_shield)/h_1))-(T1-T1))/(t_shield+(2*k_st/h_1))
        C2_S = T1 + (q_0S/(h_1*mu_st)) + C1*(k_st/h_1) + (q_0S/(k_st*mu_st**2))

        # ======================================
        # T profiles across the vessel wall, average Ts, maxima and their positions
        # ======================================
        T_vessel = lambda r: -((q_0/(k_st*mu_st**2))*np.exp(-mu_st*(r-R_int))) + C1*(r-R_int) + C2
        T_vessel_avg = (1/t)*integrate.quad(T_vessel, R_int, R_ext)[0]
        T_vessel_max = max(T_vessel(r))
        r_T_vessel_max = r[np.argmax(T_vessel(r))]

        # ======================================
        # T profiles across the thermal shield, average Ts, maxima and their positions
        # ======================================
        T_shield = lambda r: -((q_0S/(k_st*mu_st**2))*np.exp(-mu_st*(r-R_shield_int))) + C1_S*(r-R_shield_int) + C2_S
        T_shield_avg = (1/t_shield)*integrate.quad(T_shield, R_shield_int, R_shield_ext)[0]
        T_shield_max = max(T_shield(r_S))
        r_T_shield_max = r_S[np.argmax(T_shield(r_S))]

        # ======================================
        # Thermal power fluxes (kW/m²) on the inner and outer vessel surface
        # ======================================
        DeltaT_1 = T1 - T_vessel(r[0])
        q_s1 = h_1*DeltaT_1/1000                                               #kW/m²
        q_s2 = u_2*(T_vessel(r[-1])-T_cpp)/1000                                #kW/m²

        # ======================================
        # Vessel Thermal stresses computation
        # ======================================
        f_V = lambda r: T_vessel(r)*r

        sigma_r_th_V = np.zeros(dr)
        sigma_t_th_V = np.zeros(dr)
        for i in range(len(r)):
            sigma_r_th_V[i] = (E*alpha_l/(1-nu))*(1/(r[i]**2)) * (( ((r[i]**2)-(R_int**2))/((R_ext**2)-(R_int**2)) ) * simpcomp(f_V, R_int, R_ext, dr) - simpcomp(f_V, R_int, r[i], dr))
            sigma_t_th_V[i] = (E*alpha_l/(1-nu))*(1/(r[i]**2)) * (( (((r[i]**2)+(R_int**2))/((R_ext**2)-(R_int**2)) ) * simpcomp(f_V, R_int, R_ext, dr)) + simpcomp(f_V, R_int, r[i], dr) - T_vessel(r[i])*(r[i]**2))
        sigma_t_th_V_SIMP = lambda r: (E*alpha_l/(1-nu))*(T_vessel_avg - T_vessel(r))                  #Simplified formula assuming average T
        sigma_z_th_V = sigma_r_th_V + sigma_t_th_V                                                     #Superposition principle under the hypothesis of long, hollow cylinder with load-free ends

        sigma_t_th_V_max = max(sigma_t_th_V)
        r_sigma_t_th_V_max = r[np.argmax(sigma_t_th_V)]
        sigma_t_th_V_max_SIMP = max(sigma_t_th_V_SIMP(r))
        r_sigma_t_th_V_max_SIMP = r[np.argmax(sigma_t_th_V_SIMP(r))]
        
        # ======================================
        # Thermal Shield Thermal stresses computation
        # ======================================
        f_S = lambda r: T_shield(r)*r

        sigma_r_th_S = np.zeros(dr)
        sigma_t_th_S = np.zeros(dr)
        for i in range(len(r_S)):
            sigma_r_th_S[i] = (E*alpha_l/(1-nu))*(1/(r_S[i]**2)) * (( ((r_S[i]**2)-(R_shield_int**2))/((R_shield_ext**2)-(R_shield_int**2)) ) * simpcomp(f_S, R_shield_int, R_shield_ext, dr) - simpcomp(f_S, R_shield_int, r_S[i], dr))
            sigma_t_th_S[i] = (E*alpha_l/(1-nu))*(1/(r_S[i]**2)) * (( (((r_S[i]**2)+(R_shield_int**2))/((R_shield_ext**2)-(R_shield_int**2)) ) * simpcomp(f_S, R_shield_int, R_shield_ext, dr)) + simpcomp(f_S, R_shield_int, r_S[i], dr) - T_shield(r_S[i])*(r_S[i]**2))
        sigma_t_th_S_SIMP = lambda r: (E*alpha_l/(1-nu))*(T_shield_avg - T_shield(r))                  #Simplified formula assuming average T
        sigma_z_th_S = sigma_r_th_S + sigma_t_th_S                                                     #Superposition principle under the hypothesis of long, hollow cylinder with load-free ends

        sigma_t_th_S_max = max(sigma_t_th_S)
        r_sigma_t_th_S_max = r_S[np.argmax(sigma_t_th_S)]
        sigma_t_th_S_max_SIMP = max(sigma_t_th_S_SIMP(r))
        r_sigma_t_th_S_max_SIMP = r[np.argmax(sigma_t_th_S_SIMP(r))]

        # ======================================
        # Hydrostatic Stresses and Principal Stresses in the thermal shield 
        # ======================================
        sigma_L_S = sigmaL_func(r_S, P_int_MPa, P_int_MPa, 0)
        sigma_rL_S = sigma_L_S[0]  
        sigma_tL_S = sigma_L_S[1]
        sigma_zL_S = sigma_L_S[2]
        
        sigma_r_totL_S = sigma_rL_S + sigma_r_th_S
        sigma_t_totL_S = sigma_tL_S + sigma_t_th_S
        sigma_z_totL_S = sigma_zL_S + sigma_z_th_S

        # ============================ 
        # Thermal Shield Comparison stress - Guest-Tresca Theory - Lamé + Thermal stresses
        # ============================
        sigma_cTR_LS = np.max([abs(sigma_t_totL_S - sigma_r_totL_S), abs(sigma_z_totL_S - sigma_r_totL_S), abs(sigma_t_totL_S - sigma_z_totL_S)])

        # ============================ 
        # Thermal Shield Comparison stress - Von Mises Theory - Lamé + Thermal stresses
        # ============================
        sigma_cVM_LS = max(np.sqrt(0.5*((sigma_r_totL_S - sigma_t_totL_S)**2 + (sigma_t_totL_S - sigma_z_totL_S)**2 + (sigma_z_totL_S - sigma_r_totL_S)**2))) #The max should be the worst case, in theory

        # ======================================
        # Principal stresses in the vessel
        # ======================================
        sigma_r_totM = sigma_rM_cyl + sigma_r_th_V
        sigma_t_totM = sigma_tM_cyl + sigma_t_th_V
        sigma_z_totM = sigma_zM_cyl + sigma_z_th_V
        
        sigma_r_totL = sigma_rL + sigma_r_th_V
        sigma_t_totL = sigma_tL + sigma_t_th_V
        sigma_z_totL = sigma_zL + sigma_z_th_V

        # ======================================
        # Maximum Hoop Thermal Stress in the vessel via design curves
        # ======================================
        for i in range(len(indexes)):
            if mu_st > mu_values[i] and mu_st < mu_values[i+1]:
                mu_L = mu_values[i]
                mu_R = mu_values[i+1]
                #print("Current mu values: ", mu_values[i], mu_st, mu_values[i+1])
                current_L_key, current_R_key = keys_list[i], keys_list[i+1]
                x_points_L, x_points_R = mu_curves[current_L_key][2][:,0], mu_curves[current_R_key][2][:,0]
                y_points_L, y_points_R = mu_curves[current_L_key][2][:,1], mu_curves[current_R_key][2][:,1]

                p_L = np.polyfit(x_points_L, y_points_L, deg = 3) #len(y_points_L)-1
                p_R = np.polyfit(x_points_R, y_points_R, deg = 3)

                L_Interpolator = lambda x: np.polyval(p_L, x)
                R_Interpolator = lambda x: np.polyval(p_R, x)

                sigmaT_L_V = L_Interpolator(R_ext/R_int)                                                                                      #Interpolated sigmaT coefficient on the left ISO-mu 
                sigmaT_R_V = R_Interpolator(R_ext/R_int)                                                                                      #Interpolated sigmaT coefficient on the right ISO-mu
                sigmaT_L_S = L_Interpolator(R_shield_ext/R_shield_int)
                sigmaT_R_S = R_Interpolator(R_shield_ext/R_shield_int)

                sigmaT_eq_V = lambda x: sigmaT_L_V + ((sigmaT_R_V-sigmaT_L_V)/(mu_R-mu_L))*(x - mu_L)
                sigmaT_eq_S = lambda x: sigmaT_L_S + ((sigmaT_R_S-sigmaT_L_S)/(mu_R-mu_L))*(x - mu_L)
                sigmaT_V = sigmaT_eq_V(mu_st)                                                                                         #Double-interpolated (linear) sigmaT coefficient
                sigmaT_S = sigmaT_eq_S(mu_st)
        
        sigma_t_th_V_max_DES = sigmaT_V*(alpha_l*E*q_0)/(k_st*(1-nu)*(mu_st**2))
        sigma_t_th_S_max_DES = sigmaT_S*(alpha_l*E*q_0S)/(k_st*(1-nu)*(mu_st**2))
        
        # ============================ 
        # Vessel Comparison stress - Guest-Tresca Theory - Mariotte/Lamé + Thermal stresses
        # ============================
        sigma_cTR_M = np.max([abs(sigma_t_totM - sigma_r_totM), abs(sigma_z_totM - sigma_r_totM), abs(sigma_t_totM - sigma_z_totM)])
        sigma_cTR_L = np.max([abs(sigma_t_totL - sigma_r_totL), abs(sigma_z_totL - sigma_r_totL), abs(sigma_t_totL - sigma_z_totL)])

        # ============================ 
        # Vessel Comparison stress - Von Mises Theory - Mariotte/Lamé + Thermal stresses
        # ============================
        sigma_cVM_M = max(np.sqrt(0.5*((sigma_r_totM - sigma_t_totM)**2 + (sigma_t_totM - sigma_z_totM)**2 + (sigma_z_totM - sigma_r_totM)**2)))
        sigma_cVM_L = max(np.sqrt(0.5*((sigma_r_totL - sigma_t_totL)**2 + (sigma_t_totL - sigma_z_totL)**2 + (sigma_z_totL - sigma_r_totL)**2))) #The max should be the worst case, in theory
        
        # ============================ 
        # Yield Stress and Stress Intensity Data Interpolation
        # ============================
        T_des_vessel = T_vessel_avg                                                     #K  -   Check in the HARVEY/Thermomechanics Chapter how to choose the design T
        T_des_vessel_C = T_des_vessel - 273.15                                          #°C
        T_des_shield = T_shield_avg                                                     #K
        T_des_shield_C = T_des_shield - 273.15                                          #°C

        Yield_stress = Yield_CubicSpline(T_des_vessel_C)
        Stress_Intensity = Intensity_CubicSpline(T_des_vessel_C)
    
        Yield_stress_S = Yield_CubicSpline(T_des_shield_C)
        Stress_Intensity_S = Intensity_CubicSpline(T_des_shield_C)

        # ======================================
        # Thermal Shield Thermomechanical Integrity Verification
        # ======================================
        if max(abs(sigma_r_totL_S)) > 3*Stress_Intensity_S or max(abs(sigma_t_totL_S)) > 3*Stress_Intensity_S or max(abs(sigma_z_totL_S)) > 3*Stress_Intensity_S:
            flag_primsec = 1
        else:
            flag_primsec = 0

        if max(abs(sigma_rL_S)) > Stress_Intensity_S or max(abs(sigma_tL_S)) > Stress_Intensity_S or sigma_zL_S > Stress_Intensity_S:
            flag_prim = 1
        else:
            flag_prim = 0
        
        if flag_primsec == 1 or flag_prim == 1:
            print("\nThe current stress state in the thermal shield is not acceptable. \nPrimary + Secondary Stresses flag: %d \nPrimary Stresses flag: %d" %(flag_primsec, flag_prim))
            print("Absolute value of the maximum radial thermal stress: %.3f MPa\nAbsolute value of the maximum hoop thermal stress: %.3f MPa\nAbsolute value of the maximum axial thermal stress: %.3f MPa" %(abs(max(sigma_r_th_S)),abs(max(sigma_t_th_S)),abs(max(sigma_z_th_S))))
            continue
        elif flag_primsec == 0 and flag_prim == 0:
            Corradi_flag = 1                                                #Only enters the Corradi procedure if the thermal shield is ok

        # ============================ 
        # Corradi Design Procedure
        # ============================
        q_E_fun = lambda Dt: 2 * (E/(1-(nu**2))) * (1/(Dt*((Dt-1)**2)))     #Elastic Instability Limit for Thick Tubes
        q_0_fun = lambda Dt: 2 * Yield_stress * 1/Dt * (1+(1/(2*Dt)))       #Plastic Collapse Limit for Thick Tubes
        Dt_Crit_Ratio = np.sqrt(E/(Yield_stress*(1-(nu**2))))
        Current_Slenderness = (D_vess_int+2*t)/t

        if Corradi_flag == 1:
            def Corradi(Slenderness):
                if isinstance(Slenderness, np.ndarray):
                    mu = np.zeros(len(Slenderness))
                    Z = lambda Dt: (np.sqrt(3)/4) * (2*Dt + 1) * W                  #Accounts for ovality
                    q_U = lambda Dt: q_0_fun(Dt)/np.sqrt(1+(Z(Dt)**2))
                    q_L = lambda Dt: (1/2) * (q_0_fun(Dt) + q_E_fun(Dt)*(1 + Z(Dt)) - np.sqrt(((q_0_fun(Dt) + q_E_fun(Dt)*(1 + Z(Dt)))**2)-(4 * q_0_fun(Dt) * q_E_fun(Dt))))
                    
                    for i in range(len(mu)):
                        if q_0_fun(Slenderness[i])/q_E_fun(Slenderness[i]) < 0.04:
                            mu[i] = 1
                        elif 0.04 <= q_0_fun(Slenderness[i])/q_E_fun(Slenderness[i]) <= 0.7:
                            mu[i] = (0.35 * np.log(q_E_fun(Slenderness[i])/q_0_fun(Slenderness[i]))) - 0.125
                        elif q_0_fun(Slenderness[i])/q_E_fun(Slenderness[i]) > 0.7:
                            mu[i] = 0
                        
                    q_C = mu*q_U(Slenderness) + (1-mu)*q_L(Slenderness)
                    q_a = q_C/s
                else:
                    raise TypeError("The 1st input must be a numpy array.")
                if len(q_C) == 1:
                    q_C = q_C.item()
                if len(q_a) == 1:
                    q_a = q_a.item()
                if len(mu) == 1:
                    mu = mu.item()
                return (q_C, q_a, s, mu)
            
            # ============================ 
            # Corradi Design Procedure Results
            # ============================
            Corradi_vessel = Corradi(np.array([Current_Slenderness]))
            if (P_cpp < 10*Corradi_vessel[1] and sigma_cTR_M < sigma_allowable and sigma_cTR_L < sigma_allowable):
                final_flag = 1
            else:
                final_flag = 0
    
    # ======================================
    # Plotting the volumetric heat source profiles 
    # ======================================
    while True:
        try:
            hs_flag = int(input("\nDo you want to visualize the volumetric heat source q0 inside the vessel's wall and in the thermal shield? (1: Yes, 0: No): "))
            if hs_flag not in (0, 1):
                raise RuntimeError("Invalid input! Please enter either 0 or 1.")
            break  
        except ValueError:
            print("Please enter a valid integer.")
        except RuntimeError as e:
            print(e)

    if hs_flag == 1:
        # ======================================
        # Thermal Shield
        # ======================================
        plt.figure(figsize=(15,15))
        plt.subplot(1,2,1)
        if R_shield_ext - R_shield_int > 0.1:
            plt.xlim(D_barr_ext/2, R_int)
            plt.axvline(x = D_barr_ext/2, color='black', linewidth='3', label='Barrel Outer Surface')
            plt.axvline(x = R_int, color='black', linewidth='3', label='Vessel Inner Surface')
        else:
            plt.xlim(R_shield_int - 0.05, R_shield_ext + 0.05)
        plt.axvline(x = R_shield_int, color='black', linewidth='3', label='Thermal Shield Inner Surface')
        plt.axvline(x = R_shield_ext, color='black', linewidth='3', label='Thermal Shield Outer Surface')
        plt.plot(r_S, q_iiiS(r_S), 'g', label='Radial (r) Volumetric heat source profile')
        plt.plot(r_S[0], q_iiiS(r_S[0]), 'or', label='Thermal Shield Inner Surface Value')
        plt.plot(r_S[-1], q_iiiS(r_S[-1]), 'or', label='Thermal Shield Outer Surface Value')
        plt.axhline(y = 0, color='black', linewidth='1', label='y=0')
        plt.xlabel('Radius (m)')
        plt.ylabel(r'$q_0$ (W/m$^3$)')
        plt.title('Volumetric heat source profile across the thermal shield')
        plt.legend()
        plt.grid()

        # ======================================
        # Vessel
        # ======================================
        plt.subplot(1,2,2)
        plt.axvline(x = R_int, color='black', linewidth='3', label='Vessel Surface')
        plt.axvline(x = R_ext, color='black', linewidth='3')
        plt.plot(r, q_iii(r), 'g', label='Radial (r) Volumetric heat source profile')
        plt.plot(r[0], q_iii(r[0]), 'or', label='Vessel Inner Surface Value')
        plt.plot(r[-1], q_iii(r[-1]), 'or', label='Vessel-Insulation Interface Value')
        plt.axhline(y = 0, color='black', linewidth='1', label='y=0')
        plt.xlabel('Radius (m)')
        plt.ylabel(r'$q_0$ (W/m$^3$)')
        plt.title('Volumetric heat source profile across the vessel wall')
        plt.legend()
        plt.grid()
        plt.show()

    # ======================================
    # Plotting the T profiles
    # ======================================
    while True:
        try:
            T_pl_flag = int(input("\nDo you want to visualize the T profile across the vessel's wall and the thermal shield? (1: Yes, 0: No): "))
            if T_pl_flag not in (0, 1):
                raise RuntimeError("Invalid input! Please enter either 0 or 1.")
            break  
        except ValueError:
            print("Please enter a valid integer.")
        except RuntimeError as e:
            print(e)
    
    if adiab_flag == 0:
        print("\nAverage Vessel Temperature (numerical integration): %.3f °C" %(T_vessel_avg - 273.15))
        print("Maximum Vessel Temperature: %.3f °C at r = %.3f m" %(T_vessel_max - 273.15, r_T_vessel_max))
        print("Vessel Temperature at the inner surface: %-3f °C at r = %.3f m" %(T_vessel(r)[0] - 273.15, r[0]))
        print("Vessel Temperature at the outer surface: %-3f °C at r = %.3f m" %(T_vessel(r)[-1] - 273.15, r[-1]))

        print("\nAverage Thermal Shield Temperature (numerical integration): %.3f °C" %(T_shield_avg - 273.15))
        print("Maximum Thermal Shield Temperature: %.3f °C at r = %.3f m" %(T_shield_max - 273.15, r_T_vessel_max))
        print("Thermal Shield Temperature at the inner surface: %-3f °C at r = %.3f m" %(T_shield(r_S)[0] - 273.15, r_S[0]))
        print("Thermal Shield Temperature at the outer surface: %-3f °C at r = %.3f m" %(T_shield(r_S)[-1] - 273.15, r_S[-1]))
        if T_pl_flag == 1:

            # ======================================
            # Thermal Shield T Profile
            # ======================================
            plt.figure(figsize=(15,15))
            plt.subplot(1,2,1)
            if R_shield_ext - R_shield_int > 0.1:
                plt.xlim(D_barr_ext/2, R_int)
                plt.axvline(x = D_barr_ext/2, color='black', linewidth='3', label='Barrel Outer Surface')
                plt.axvline(x = R_int, color='black', linewidth='3', label='Vessel Inner Surface')
            else:
                plt.xlim(R_shield_int - 0.05, R_shield_ext + 0.05)
            plt.axvline(x = R_shield_int, color='black', linewidth='3', label='Thermal Shield Inner Surface')
            plt.axvline(x = R_shield_ext, color='black', linewidth='3', label='Thermal Shield Outer Surface')
            plt.plot(r_S, T_shield(r_S) - 273.15, label='Radial (r) T Profile')
            plt.plot(r_T_shield_max, T_shield_max - 273.15,'or',label='Max T')
            plt.axhline(y = T_shield_avg - 273.15, color='green', label='Thermal Shield Average T')
            plt.xlabel('Radius (m)')
            plt.ylabel('T (°C)')
            plt.title('Thermal Shield Temperature Profile, Average and Maximum ')
            plt.legend()
            plt.grid()

            # ======================================
            # Vessel T Profile
            # ======================================
            plt.subplot(1,2,2)
            plt.axvline(x = R_int, color='black', linewidth='3', label='Vessel Inner Surface')
            plt.axvline(x = R_ext, color='black', linewidth='3', label='Vessel Outer Surface')
            plt.plot(r, T_vessel(r) - 273.15, label='Radial (r) T Profile')
            plt.plot(r_T_vessel_max, T_vessel_max - 273.15,'or',label='Max T')
            plt.axhline(y = T_vessel_avg - 273.15, color='green', label='Vessel Wall Average T')
            plt.xlabel('Radius (m)')
            plt.ylabel('T (°C)')
            plt.title('Vessel Wall Temperature Profile, Average and Maximum ')
            plt.legend()
            plt.grid()
            plt.show()
        
    elif adiab_flag == 1:
        print("\nAverage Vessel Temperature under Adiabatic Outer Wall approximation (numerical integration): %.3f °C" %(T_vessel_avg - 273.15))
        print("Maximum Vessel Temperature under Adiabatic Outer Wall approximation: %.3f °C at r = %.3f m" %(T_vessel_max - 273.15, r_T_vessel_max))
        print("Vessel Temperature at the inner surface under Adiabatic Outer Wall approximation: %-3f °C at r = %.3f m" %(T_vessel(r)[0] - 273.15, r[0]))
        print("Vessel Temperature at the outer surface under Adiabatic Outer Wall approximation: %-3f °C at r = %.3f m" %(T_vessel(r)[-1] - 273.15, r[-1]))

        print("\nAverage Thermal Shield Temperature (numerical integration): %.3f °C" %(T_shield_avg - 273.15))
        print("Maximum Thermal Shield Temperature: %.3f °C at r = %.3f m" %(T_shield_max - 273.15, r_T_vessel_max))
        print("Thermal Shield Temperature at the inner surface: %-3f °C at r = %.3f m" %(T_shield(r_S)[0] - 273.15, r_S[0]))
        print("Thermal Shield Temperature at the outer surface: %-3f °C at r = %.3f m" %(T_shield(r_S)[-1] - 273.15, r_S[-1]))
        if T_pl_flag == 1:
            
            # ======================================
            # Thermal Shield T Profile
            # ======================================
            plt.figure(figsize=(15,15))
            plt.subplot(1,2,1)
            if R_shield_ext - R_shield_int > 0.1:
                plt.xlim(D_barr_ext/2, R_int)
                plt.axvline(x = D_barr_ext/2, color='black', linewidth='3', label='Barrel Outer Surface')
                plt.axvline(x = R_int, color='black', linewidth='3', label='Vessel Inner Surface')
            else:
                plt.xlim(R_shield_int - 0.05, R_shield_ext + 0.05)
            plt.axvline(x = R_shield_int, color='black', linewidth='3', label='Thermal Shield Inner Surface')
            plt.axvline(x = R_shield_ext, color='black', linewidth='3', label='Thermal Shield Outer Surface')
            plt.plot(r_S, T_shield(r_S) - 273.15, label='Radial (r) T Profile')
            plt.plot(r_T_shield_max, T_shield_max - 273.15,'or',label='Max T')
            plt.axhline(y = T_shield_avg - 273.15, color='green', label='Thermal Shield Average T')
            plt.xlabel('Radius (m)')
            plt.ylabel('T (°C)')
            plt.title('Thermal Shield Temperature Profile, Average and Maximum ')
            plt.legend()
            plt.grid()
            
            # ======================================
            # Vessel Under Adiabatic Outer Wall Approximation
            # ======================================
            plt.subplot(1,2,2)
            plt.axvline(x = R_int, color='black', linewidth='3', label='Vessel Inner Surface')
            plt.axvline(x = R_ext, color='black', linewidth='3', label='Vessel Outer Surface')
            plt.plot(r, T_vessel(r) - 273.15, label='Radial (r) T Profile')
            plt.plot(r_T_vessel_max, T_vessel_max - 273.15,'or', label='Max T')
            plt.axhline(y = T_vessel_avg - 273.15, color='green', label='Wall Average T')
            plt.xlabel('Radius (m)')
            plt.ylabel('T (°C)')
            plt.title('Wall Temperature Profile, Average and Maximum under AOW Approximation ')
            plt.legend()
            plt.grid()
            plt.show()

    # ======================================
    # Plotting the thermal stress profiles
    # ======================================
    while True:
        try:
            sigma_th_pl_flag = int(input("\nDo you want to visualize a plot of the thermal stress profiles in the vessel and in the thermal shield? (1: Yes, 0: No): "))
            if sigma_th_pl_flag not in (0, 1):
                raise RuntimeError("Invalid input! Please enter either 0 or 1.")
            break  
        except ValueError:
            print("Please enter a valid integer.")
        except RuntimeError as e:
            print(e)

    if sigma_th_pl_flag == 1:

        # ======================================
        # Thermal shield thermal stress profiles
        # ======================================
        plt.figure(figsize=(15,15))
        plt.subplot(1,2,1)
        if R_shield_ext - R_shield_int > 0.1:
            plt.xlim(D_barr_ext/2, R_int)
            plt.axvline(x = D_barr_ext/2, color='black', linewidth='3', label='Barrel Outer Surface')
            plt.axvline(x = R_int, color='black', linewidth='3', label='Vessel Inner Surface')
        else:
            plt.xlim(R_shield_int - 0.05, R_shield_ext + 0.05)
        plt.axvline(x = R_shield_int, color='black', linewidth='3', label='Thermal Shield Inner Surface')
        plt.axvline(x = R_shield_ext, color='black', linewidth='3', label='Thermal Shield Outer Surface')
        plt.plot(r_S, sigma_r_th_S, linewidth='0.75', label='Radial (r) Thermal Stress Profile')
        plt.plot(r_S, sigma_t_th_S, linewidth='0.75', label='Hoop (θ) Thermal Stress Profile')
        plt.plot(r_S, sigma_z_th_S, color='green', linewidth='0.5', label='Axial (z) Thermal Stress Profile')
        plt.axhline(y = 0, color='black', linewidth='1', label='y=0')
        plt.plot(r_sigma_t_th_S_max, sigma_t_th_S_max,'or', label='Max Hoop Stress')
        plt.xlabel('Radius (m)')
        plt.ylabel('Thermal Stress (MPa)')
        plt.title('Thermal Shield Thermal Stress Profiles and Maximum Hoop Stress')
        plt.legend()
        plt.grid()
        
        # ======================================
        # Vessel thermal stress profiles
        # ======================================
        plt.subplot(1,2,2)
        plt.axvline(x = R_int, color='black', linewidth='3', label='Vessel Inner Surface')
        plt.axvline(x = R_ext, color='black', linewidth='3', label='Vessel Outer Surface')
        plt.plot(r, sigma_r_th_V, linewidth='0.75', label='Radial (r) Thermal Stress Profile')
        plt.plot(r, sigma_t_th_V, linewidth='0.75', label='Hoop (θ) Thermal Stress Profile')
        plt.plot(r, sigma_z_th_V, color='green', linewidth='0.5', label='Axial (z) Thermal Stress Profile')
        plt.axhline(y = 0, color='black', linewidth='1', label='y=0')
        plt.plot(r_sigma_t_th_V_max, sigma_t_th_V_max,'or', label='Max Hoop Stress')
        plt.xlabel('Radius (m)')
        plt.ylabel('Thermal Stress (MPa)')
        plt.title('Vessel Wall Thermal Stress Profiles and Maximum Hoop Stress')
        plt.legend()
        plt.grid()
        plt.show()

    # ======================================
    # Plotting the maximum thermal stress via the design curves
    # ======================================
    while True:
        try:
            des_pl_flag = int(input("\nDo you want to visualize a plot of the design curves and the maximum thermal stress in the vessel and in the thermal shield? (1: Yes, 0: No): "))
            if des_pl_flag not in (0, 1):
                raise RuntimeError("Invalid input! Please enter either 0 or 1.")
            break  
        except ValueError:
            print("Please enter a valid integer.")
        except RuntimeError as e:
            print(e)

    if des_pl_flag == 1:
        plt.figure(figsize=(10,10))
        plt.plot(ba_ratio_plot, L_Interpolator(ba_ratio_plot), 'k', label=f'Iso-mu = {mu_L} 1/m')
        plt.plot(ba_ratio_plot, R_Interpolator(ba_ratio_plot), 'k', label=f'Iso-mu = {mu_R} 1/m')
        plt.plot(R_ext/R_int, sigmaT_V,'or', label=r'Current $\sigma$$_T$ in the vessel')
        plt.plot(R_shield_ext/R_shield_int, sigmaT_S,'ob', label=r'Current $\sigma$$_T$ in the thermal shield')
        plt.xlabel('b/a')
        plt.ylabel(r'$\sigma$$_T$')
        plt.title('Design curves')
        plt.legend()
        plt.grid()
        plt.show()

    # ======================================
    # Plotting the yield stress and stress intensity curves
    # ======================================
    while True:
        try:
            Interp_pl_flag = int(input("\nDo you want to visualize a plot of the Yield Stress and Stress Intensity as given by ASME for both the vessel and the thermal shield? (1: Yes, 0: No): "))
            if Interp_pl_flag not in (0, 1):
                raise RuntimeError("Invalid input! Please enter either 0 or 1.")
            break  
        except ValueError:
            print("Please enter a valid integer.")
        except RuntimeError as e:
            print(e)
    
    if max(T_thr) > T_des_vessel_C:
        Tplot = np.linspace(min(T_thr), max(T_thr), 1000)
    else:
        Tplot = np.linspace(min(T_thr), T_des_vessel_C, 1000)
    
    if Interp_pl_flag == 1:
        
        # ============================ 
        # Yield Stress
        # ============================
        plt.figure(figsize = (12,10))
        plt.subplot(1,2,1)
        plt.plot(T_thr, sigma_y, 'sk', label = 'Yield Stress Data')
        plt.plot(Tplot, Yield_Interpolator(Tplot), '--', color = 'orange', label = 'Yield Stress n-1 Interpolation')
        plt.plot(Tplot, Yield_CubicSpline(Tplot), 'green', label = 'Yield Stress Cubic Spline Interpolation')
        plt.plot(T_des_vessel_C, Yield_stress, '--or', label = r'Current Vessel Yield Stress $\sigma$$_y$')
        plt.plot(T_des_shield_C, Yield_stress_S, '--ob', label = r'Current Thermal Shield Yield Stress $\sigma$$_y$')
        plt.xlabel("Temperature (°C)")
        plt.ylabel(r"Yield Stress $\sigma$$_y$")
        plt.title("Yield Stress Data and Interpolation VS Temperature", fontsize = 10)
        plt.legend()
        plt.grid()
        plt.tight_layout()

        # ============================ 
        # Stress intensity
        # ============================
        plt.subplot(1,2,2)
        plt.plot(T_thr, sigma_in, 'sk', label = 'Stress Intensity Data')
        plt.plot(Tplot, Intensity_Interpolator(Tplot), '--', color = 'orange', label = 'Stress Intensity n-1 Interpolation')
        plt.plot(Tplot, Intensity_CubicSpline(Tplot), 'green', label = 'Stress Intensity Cubic Spline Interpolation')
        plt.plot(T_des_vessel_C, Stress_Intensity, '--or', label = r'Current Vessel Stress Intensity $\sigma$$_m$')
        plt.plot(T_des_shield_C, Stress_Intensity_S, '--ob', label = r'Current Thermal Shield Stress Intensity $\sigma$$_m$')
        plt.xlabel("Temperature (°C)")
        plt.ylabel(r"Stress Intensity $\sigma$$_m$")
        plt.title("Stress Intensity Data and Interpolation VS Temperature", fontsize = 10)
        plt.legend()
        plt.grid()
        plt.tight_layout()
        plt.show()

    print("\nVolumetric heat source at the vessel inner surface: %.3f W/m³" %q_iii(r[0]))
    print("Volumetric heat source at the vessel-insulation interface: %.3f W/m³" %q_iii(r[-1]))

    print("\nHeat transfer coefficient h1 = %.3f W/(m²·K)" %h_1)
    print("Heat transfer coefficient h2 = %.3f W/(m²·K)" %h_2)
    print("Overall heat transfer coefficient outside the vessel u2 = %.3f W/(m²·K)" %u_2)
    
    print("\nThermal power flux on the inner vessel surface: %.3f kW/m²" %q_s1)
    print("Thermal power flux on the outer vessel surface: %.3f kW/m²" %q_s2)
    
    print("\nMaximum Thermal Hoop Stress in the vessel: %.3f Mpa at r = %.3f m" %(sigma_t_th_V_max, r_sigma_t_th_V_max))
    #print("Maximum Thermal Hoop Stress in the vessel (Simplified formula): %.3f Mpa at r = %.3f m" %(sigma_t_th_V_max_SIMP, r_sigma_t_th_V_max_SIMP))
    print("Maximum thermal hoop stress in the vessel via design curves: %.3f MPa" %sigma_t_th_V_max_DES)

    print("Maximum Thermal Hoop Stress in the thermal shield: %.3f Mpa at r = %.3f m" %(sigma_t_th_S_max, r_sigma_t_th_S_max))
    #print("Maximum Thermal Hoop Stress in the thermal shield (Simplified formula): %.3f Mpa at r = %.3f m" %(sigma_t_th_S_max_SIMP, r_sigma_t_th_S_max_SIMP))
    print("Maximum thermal hoop stress in the thermal shield via design curves: %.3f MPa" %sigma_t_th_S_max_DES)

    print("\nGuest-Tresca Equivalent Stress in the vessel - Mariotte solution: %.3f Mpa" %sigma_cTR_M)
    print("Guest-Tresca Equivalent Stress in the vessel - Lamé solution: %.3f Mpa" %sigma_cTR_L)

    print("\nFor a design vessel temperature of %.3f °C: " %T_des_vessel_C)
    print('Yield Stress: Sy'," = %.3f MPa" %Yield_stress)
    print('Stress Intensity: Sm'," = %.3f MPa" %Stress_Intensity)

    print("\nFor a design thermal shield temperature of %.3f °C: " %T_des_shield_C)
    print('Yield Stress: Sy'," = %.3f MPa" %Yield_stress_S)
    print('Stress Intensity: Sm'," = %.3f MPa" %Stress_Intensity_S)

    # ============================ 
    # Sizing of a thick cylinder under external pressure
    # ============================
    if R_int/t > 5:
        while True:
            try:
                ThinTubes_flag = int(input("\nWith a thickness value of %.3f m, the vessel can be considered thin. Are you interested in the thin tube limits for Elastic Instability and Plastic Collapse? (1: Yes, 0: No): " %t))
                if ThinTubes_flag not in (0, 1):
                    raise RuntimeError("Invalid input! Please enter either 0 or 1.")
                break  
            except ValueError:
                print("Please enter a valid integer.")
            except RuntimeError as e:
                print(e)

        if ThinTubes_flag == 1:
            p_E_fun = lambda Dt: 2 * (E/(1-(nu**2))) * (1/(Dt**3))              #Elastic Instability Limit for Thin Tubes
            p_0_fun = lambda Dt: 2 * Yield_stress * 1/Dt                        #Plastic Collapse Limit for Thin Tubes  -   Vessel
            p_0_fun_S = lambda Dt: 2 * Yield_stress_S * 1/Dt                    #Plastic Collapse Limit for Thin Tubes  -   Thermal Shield

        elif ThinTubes_flag == 0:
            print("Skipping thin tube limits.")
    else:
        print("\nThe cylinder can't be considered thin. Skipping thin tube limits.")
        ThinTubes_flag = 0

    if ThinTubes_flag == 1:
        while True:
            try:
                Corradi_flag = int(input("\nThe thin tube limits were adopted. Are you interested in the more general Corradi Design Procedure? (1: Yes, 0: No): "))
                if Corradi_flag not in (0, 1):
                    raise RuntimeError("Invalid input! Please enter either 0 or 1.")
                break  
            except ValueError:
                print("Please enter a valid integer.")
            except RuntimeError as e:
                print(e)
        if Corradi_flag == 0:
            # ============================ 
            # Elastic instability and plastic collapse curves
            # ============================
            while True:
                try:
                    Collapse_pl_flag = int(input("\nDo you want to visualize the buckling and plastic collapse curves for thin and thick tubes? (1: Yes, 0: No): "))
                    if Collapse_pl_flag not in (0, 1):
                        raise RuntimeError("Invalid input! Please enter either 0 or 1.")
                    break  
                except ValueError:
                    print("Please enter a valid integer.")
                except RuntimeError as e:
                    print(e)
            
            if Collapse_pl_flag == 1:
                # ============================ 
                # Plastic collapse and buckling plots
                # ============================
                plt.figure(figsize = (8, 8))
                plt.semilogy(Dt_ratio_plot, p_E_fun(Dt_ratio_plot), 'blue', label='p$_E$')
                plt.semilogy(Dt_ratio_plot, q_E_fun(Dt_ratio_plot), '--b', label='q$_E$')
                plt.semilogy(Dt_ratio_plot, p_0_fun(Dt_ratio_plot), 'red', label='p$_0$')
                plt.semilogy(Dt_ratio_plot, q_0_fun(Dt_ratio_plot), '--r', label='q$_0$')
                plt.axvline(x = Dt_Crit_Ratio, color = 'black', linewidth = '3', label = 'Critical Slenderness')
                plt.axvline(x = Current_Slenderness, color = 'green', linewidth = '3', label = 'Current Vessel Slenderness')
                plt.xlabel("Geometrical Slenderness D/t")
                plt.ylabel("Theoretical Limit Values (MPa)")
                plt.title("Plastic Collapse and Buckling Curves")
                plt.legend()
                plt.grid()
                plt.show()

        elif Corradi_flag == 1:
            while True:
                try:
                    Collapse_pl_flag = int(input("\nDo you want to visualize the buckling and plastic collapse curves for thin and thick tubes and the Corradi curve? (1: Yes, 0: No): "))
                    if Collapse_pl_flag not in (0, 1):
                        raise RuntimeError("Invalid input! Please enter either 0 or 1.")
                    break  
                except ValueError:
                    print("Please enter a valid integer.")
                except RuntimeError as e:
                    print(e)
            
            if Collapse_pl_flag == 1:
                # ============================ 
                # Plastic collapse and buckling plots
                # ============================
                plt.figure(figsize = (8, 8))
                plt.subplot(1,2,1)
                plt.semilogy(Dt_ratio_plot, p_E_fun(Dt_ratio_plot), 'blue', label='p$_E$')
                plt.semilogy(Dt_ratio_plot, q_E_fun(Dt_ratio_plot), '--b', label='q$_E$')
                plt.semilogy(Dt_ratio_plot, p_0_fun(Dt_ratio_plot), 'red', label='p$_0$')
                plt.semilogy(Dt_ratio_plot, q_0_fun(Dt_ratio_plot), '--r', label='q$_0$')
                plt.semilogy(Dt_ratio_plot, Corradi(Dt_ratio_plot)[0], 'orange', label='Corradi q$_c$')
                plt.axvline(x = Dt_Crit_Ratio, color = 'black', linewidth = '3', label = 'Critical Slenderness')
                plt.axvline(x = Current_Slenderness, color = 'green', linewidth = '3', label = 'Current Vessel Slenderness')
                plt.xlabel("Geometrical Slenderness D/t")
                plt.ylabel("Theoretical Limit Values (MPa)")
                plt.title("Plastic Collapse and Buckling Curves")
                plt.legend()
                plt.grid()
                plt.tight_layout()

                plt.subplot(1,2,2)
                plt.plot(Dt_ratio_plot, Corradi(Dt_ratio_plot)[3], 'k', label=r'Corradi $\mu$')
                plt.xlabel("Geometrical Slenderness D/t")
                plt.ylabel(r"Corradi $\mu$")
                plt.title(r"$\mu$ coefficient - Corradi Procedure")
                plt.legend()
                plt.grid()
                plt.tight_layout()
                plt.show()
        
    elif ThinTubes_flag == 0:
        print("Adopting Corradi Design Procedure.")
        Corradi_flag = 1

    # ============================ 
    # Final Results Printing
    # ============================
    print("\n\n\n###################################################### Final  Results ######################################################")
        
    print("\nThe vessel thickness has been increased %d times by 1cm. Computed vessel thickness: %.3f m" %(counter_vessel, t))
    print("Computed thermal shield thickness: %.3f m" %t_shield)

    # ============================ 
    # Thermal Shield
    # ============================
    print("\n###################################################### Thermal Shield ######################################################")
    if flag_primsec == 1 or flag_prim == 1:
        print("\nThe current stress state in the thermal shield is not acceptable. \nPrimary + Secondary Stresses flag: %d \nPrimary Stresses flag: %d" %(flag_primsec, flag_prim))
        print("Maximum absolute value of the radial thermal stress: %.3f MPa\nMaximum absolute value of the hoop thermal stress: %.3f MPa\nMaximum absolute value of the axial thermal stress: %.3f MPa" %(max(abs(sigma_r_th_S)),max(abs(sigma_t_th_S)),max(abs(sigma_z_th_S))))
    
    elif flag_primsec == 0 and flag_prim == 0:
        print("\nThe current stress state in the thermal shield is acceptable:")
        print("\nMaximum absolute value of the total radial stress: %.3f MPa\nMaximum absolute value of the total hoop stress: %.3f MPa\nMaximum absolute value of the total axial stress: %.3f MPa" %(max(abs(sigma_r_totL_S)),max(abs(sigma_t_totL_S)),max(abs(sigma_z_totL_S))))
        print("\nAll are lower than 3Sm = %.3f MPa" %(3*Stress_Intensity_S))         
        print("\nMaximum value of the primary radial stress: %.3f MPa\nMaximum value of the primary hoop stress: %.3f MPa\nPrimary axial stress: %.3f MPa" %(max(sigma_rL_S),max(sigma_tL_S),sigma_zL_S))
        print("\nAll are lower than Sm = %.3f MPa" %Stress_Intensity_S)

    if (sigma_cTR_LS < sigma_allowable):
        print("\nThe comparison stress according to Tresca-Lamé Sc = %.3f MPa is lower than the allowable stress Sa = %.3f MPa\nThe thermal shield's integrity is ensured." %(sigma_cTR_LS, sigma_allowable))
    
    # ============================ 
    # Vessel
    # ============================
    print("\n########################################################## Vessel ##########################################################")
    Corradi_vessel = Corradi(np.array([Current_Slenderness]))
    print("\nAccording to the Corradi Design Procedure:")
    print("Current slenderness: %.3f    -   Critical slenderness: %.3f" %(Current_Slenderness, Dt_Crit_Ratio))
    print("\nThe theoretical limit for collapse pressure, accounting for ovality, is: q_c = %.3f MPa = %.3f bar" %(Corradi_vessel[0], 10*Corradi_vessel[0]))
    print("A safety factor s = %.3f was assumed. \nThe allowable external pressure is thus: q_a = %.3f MPa = %.3f bar" %(Corradi_vessel[2], Corradi_vessel[1], 10*Corradi_vessel[1]))

    if (P_cpp < 10*Corradi_vessel[1] and sigma_cTR_M < sigma_allowable and sigma_cTR_L < sigma_allowable):
        print("\nThe given external pressure of %.3f bar is lower than the allowable pressure of %.3f bar" %(P_cpp, 10*Corradi_vessel[1]))
        print("\nThe comparison stress according to Tresca-Lamé Sc = %.3f MPa is lower than the allowable stress Sa = %.3f MPa\nThe comparison stress according to Tresca-Mariotte Sc = %.3f MPa is also lower than the allowable stress Sa = %.3f MPa" %(sigma_cTR_L, sigma_allowable, sigma_cTR_M, sigma_allowable))
        print("\nThe thermal shield's integrity is ensured: the design is correct!")
        print("\n############################################################################################################################")
    elif (P_cpp > 10*Corradi_vessel[1]):
        print("\nThe given external pressure of %.3f bar is higher than the allowable pressure of %.3f bar: a change in thickness is required!" %(P_cpp, 10*Corradi_vessel[1]))
    elif (sigma_cTR_M > sigma_allowable or sigma_cTR_L > sigma_allowable):
        print("\nEither the Tresca-Mariotte comparison stress Sc = %.3f MPa or the Tresca-Lamè comparison stress Sc = %.3f MPa is higher than the allowable stress Sa = %.3f MPa" %(sigma_cTR_M,sigma_cTR_L,sigma_allowable))